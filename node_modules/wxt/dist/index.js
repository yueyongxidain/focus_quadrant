import {
  detectDevChanges,
  findEntrypoints,
  formatDuration,
  generateTypesDir,
  getContentScriptCssFiles,
  getContentScriptJs,
  getContentScriptsCssMap,
  getEntrypointBundlePath,
  getPackageJson,
  internalBuild,
  isHtmlEntrypoint,
  kebabCaseAlphanumeric,
  mapWxtOptionsToRegisteredContentScript,
  normalizePath,
  printFileList,
  rebuild,
  registerWxt,
  unnormalizePath,
  version,
  wxt
} from "./chunk-7EUSM4KG.js";
import "./chunk-5X3S6AWF.js";
import {
  consola
} from "./chunk-ZZCTFNQ5.js";
import "./chunk-VBXJIVYU.js";

// src/core/build.ts
async function build(config) {
  await registerWxt("build", config);
  return await internalBuild();
}

// src/core/clean.ts
import path from "node:path";
import glob from "fast-glob";
import fs from "fs-extra";
import pc from "picocolors";
async function clean(root = process.cwd()) {
  consola.info("Cleaning Project");
  const tempDirs = [
    "node_modules/.vite",
    "node_modules/.cache",
    "**/.wxt",
    ".output/*"
  ];
  consola.debug("Looking for:", tempDirs.map(pc.cyan).join(", "));
  const directories = await glob(tempDirs, {
    cwd: path.resolve(root),
    absolute: true,
    onlyDirectories: true,
    deep: 2
  });
  if (directories.length === 0) {
    consola.debug("No generated files found.");
    return;
  }
  consola.debug(
    "Found:",
    directories.map((dir) => pc.cyan(path.relative(root, dir))).join(", ")
  );
  for (const directory of directories) {
    await fs.rm(directory, { force: true, recursive: true });
    consola.debug("Deleted " + pc.cyan(path.relative(root, directory)));
  }
}

// src/core/define-config.ts
function defineConfig(config) {
  return config;
}

// src/core/define-runner-config.ts
function defineRunnerConfig(config) {
  return config;
}

// src/core/runners/wsl.ts
import { relative } from "node:path";
function createWslRunner() {
  return {
    async openBrowser() {
      wxt.logger.warn(
        `Cannot open browser when using WSL. Load "${relative(
          process.cwd(),
          wxt.config.outDir
        )}" as an unpacked extension manually`
      );
    },
    async closeBrowser() {
    }
  };
}

// src/core/runners/web-ext.ts
import defu from "defu";
function createWebExtRunner() {
  let runner;
  return {
    async openBrowser() {
      const startTime = Date.now();
      if (wxt.config.browser === "firefox" && wxt.config.manifestVersion === 3) {
        throw Error(
          "Dev mode does not support Firefox MV3. For alternatives, see https://github.com/wxt-dev/wxt/issues/230#issuecomment-1806881653"
        );
      }
      const webExtLogger = await import("web-ext-run/util/logger");
      webExtLogger.consoleStream.write = ({ level, msg, name }) => {
        if (level >= ERROR_LOG_LEVEL)
          wxt.logger.error(name, msg);
        if (level >= WARN_LOG_LEVEL)
          wxt.logger.warn(msg);
      };
      const wxtUserConfig = wxt.config.runnerConfig.config;
      const userConfig = {
        console: wxtUserConfig?.openConsole,
        devtools: wxtUserConfig?.openDevtools,
        startUrl: wxtUserConfig?.startUrls,
        keepProfileChanges: wxtUserConfig?.keepProfileChanges,
        ...wxt.config.browser === "firefox" ? {
          firefox: wxtUserConfig?.binaries?.firefox,
          firefoxProfile: wxtUserConfig?.firefoxProfile,
          prefs: wxtUserConfig?.firefoxPrefs,
          args: wxtUserConfig?.firefoxArgs
        } : {
          chromiumBinary: wxtUserConfig?.binaries?.[wxt.config.browser],
          chromiumProfile: wxtUserConfig?.chromiumProfile,
          chromiumPref: defu(
            wxtUserConfig?.chromiumPref,
            DEFAULT_CHROMIUM_PREFS
          ),
          args: wxtUserConfig?.chromiumArgs
        }
      };
      const finalConfig = {
        ...userConfig,
        target: wxt.config.browser === "firefox" ? "firefox-desktop" : "chromium",
        sourceDir: wxt.config.outDir,
        // WXT handles reloads, so disable auto-reload behaviors in web-ext
        noReload: true,
        noInput: true
      };
      const options = {
        // Don't call `process.exit(0)` after starting web-ext
        shouldExitProgram: false
      };
      wxt.logger.debug("web-ext config:", finalConfig);
      wxt.logger.debug("web-ext options:", options);
      const webExt = await import("web-ext-run");
      runner = await webExt.default.cmd.run(finalConfig, options);
      const duration = Date.now() - startTime;
      wxt.logger.success(`Opened browser in ${formatDuration(duration)}`);
    },
    async closeBrowser() {
      return await runner?.exit();
    }
  };
}
var WARN_LOG_LEVEL = 40;
var ERROR_LOG_LEVEL = 50;
var DEFAULT_CHROMIUM_PREFS = {
  devtools: {
    synced_preferences_sync_disabled: {
      // Remove content scripts from sourcemap debugger ignore list so stack traces
      // and log locations show up properly, see:
      // https://github.com/wxt-dev/wxt/issues/236#issuecomment-1915364520
      skipContentScripts: false
    }
  }
};

// src/core/runners/safari.ts
import { relative as relative2 } from "node:path";
function createSafariRunner() {
  return {
    async openBrowser() {
      wxt.logger.warn(
        `Cannot Safari using web-ext. Load "${relative2(
          process.cwd(),
          wxt.config.outDir
        )}" as an unpacked extension manually`
      );
    },
    async closeBrowser() {
    }
  };
}

// src/core/runners/manual.ts
import { relative as relative3 } from "node:path";
function createManualRunner() {
  return {
    async openBrowser() {
      wxt.logger.info(
        `Load "${relative3(
          process.cwd(),
          wxt.config.outDir
        )}" as an unpacked extension manually`
      );
    },
    async closeBrowser() {
    }
  };
}

// src/core/utils/wsl.ts
async function isWsl() {
  const { default: isWsl2 } = await import("is-wsl");
  return isWsl2;
}

// src/core/runners/index.ts
async function createExtensionRunner() {
  if (wxt.config.browser === "safari")
    return createSafariRunner();
  if (await isWsl())
    return createWslRunner();
  if (wxt.config.runnerConfig.config?.disabled)
    return createManualRunner();
  return createWebExtRunner();
}

// src/core/create-server.ts
import { Mutex } from "async-mutex";
import pc2 from "picocolors";
import { relative as relative4 } from "node:path";
async function createServer(inlineConfig) {
  await registerWxt("serve", inlineConfig, async (config) => {
    const { port, hostname } = config.dev.server;
    const serverInfo = {
      port,
      hostname,
      origin: `http://${hostname}:${port}`
    };
    const server2 = {
      ...serverInfo,
      get watcher() {
        return builderServer.watcher;
      },
      get ws() {
        return builderServer.ws;
      },
      currentOutput: void 0,
      async start() {
        await builderServer.listen();
        wxt.logger.success(`Started dev server @ ${serverInfo.origin}`);
        await buildAndOpenBrowser();
      },
      async stop() {
        await runner.closeBrowser();
        await builderServer.close();
      },
      async restart() {
        await closeAndRecreateRunner();
        await buildAndOpenBrowser();
      },
      transformHtml(url, html, originalUrl) {
        return builderServer.transformHtml(url, html, originalUrl);
      },
      reloadContentScript(payload) {
        server2.ws.send("wxt:reload-content-script", payload);
      },
      reloadPage(path4) {
        server2.ws.send("wxt:reload-page", path4);
      },
      reloadExtension() {
        server2.ws.send("wxt:reload-extension");
      },
      async restartBrowser() {
        await closeAndRecreateRunner();
        await runner.openBrowser();
      }
    };
    return server2;
  });
  const server = wxt.server;
  let [runner, builderServer] = await Promise.all([
    createExtensionRunner(),
    wxt.builder.createServer(server)
  ]);
  const buildAndOpenBrowser = async () => {
    server.currentOutput = await internalBuild();
    try {
      server.watcher.add(getExternalOutputDependencies(server));
    } catch (err) {
      wxt.config.logger.warn("Failed to register additional file paths:", err);
    }
    await runner.openBrowser();
  };
  const closeAndRecreateRunner = async () => {
    await runner.closeBrowser();
    await wxt.reloadConfig();
    runner = await createExtensionRunner();
  };
  server.ws.on("wxt:background-initialized", () => {
    if (server.currentOutput == null)
      return;
    reloadContentScripts(server.currentOutput.steps, server);
  });
  const reloadOnChange = createFileReloader(server);
  server.watcher.on("all", reloadOnChange);
  return server;
}
function createFileReloader(server) {
  const fileChangedMutex = new Mutex();
  const changeQueue = [];
  return async (event, path4) => {
    await wxt.reloadConfig();
    if (path4.startsWith(wxt.config.outBaseDir))
      return;
    changeQueue.push([event, path4]);
    await fileChangedMutex.runExclusive(async () => {
      if (server.currentOutput == null)
        return;
      const fileChanges = changeQueue.splice(0, changeQueue.length).map(([_, file]) => file);
      if (fileChanges.length === 0)
        return;
      const changes = detectDevChanges(fileChanges, server.currentOutput);
      if (changes.type === "no-change")
        return;
      if (changes.type === "full-restart") {
        wxt.logger.info("Config changed, restarting server...");
        server.restart();
        return;
      }
      if (changes.type === "browser-restart") {
        wxt.logger.info("Runner config changed, restarting browser...");
        server.restartBrowser();
        return;
      }
      wxt.logger.info(
        `Changed: ${Array.from(new Set(fileChanges)).map((file) => pc2.dim(relative4(wxt.config.root, file))).join(", ")}`
      );
      const allEntrypoints = await findEntrypoints();
      try {
        const { output: newOutput } = await rebuild(
          allEntrypoints,
          // TODO: this excludes new entrypoints, so they're not built until the dev command is restarted
          changes.rebuildGroups,
          changes.cachedOutput
        );
        server.currentOutput = newOutput;
        switch (changes.type) {
          case "extension-reload":
            server.reloadExtension();
            consola.success(`Reloaded extension`);
            break;
          case "html-reload":
            const { reloadedNames } = reloadHtmlPages(
              changes.rebuildGroups,
              server
            );
            consola.success(`Reloaded: ${getFilenameList(reloadedNames)}`);
            break;
          case "content-script-reload":
            reloadContentScripts(changes.changedSteps, server);
            const rebuiltNames = changes.rebuildGroups.flat().map((entry) => entry.name);
            consola.success(`Reloaded: ${getFilenameList(rebuiltNames)}`);
            break;
        }
      } catch (err) {
      }
    });
  };
}
function reloadContentScripts(steps, server) {
  if (wxt.config.manifestVersion === 3) {
    steps.forEach((step) => {
      if (server.currentOutput == null)
        return;
      const entry = step.entrypoints;
      if (Array.isArray(entry) || entry.type !== "content-script")
        return;
      const js = getContentScriptJs(wxt.config, entry);
      const cssMap = getContentScriptsCssMap(server.currentOutput, [entry]);
      const css = getContentScriptCssFiles([entry], cssMap);
      server.reloadContentScript({
        registration: entry.options.registration,
        contentScript: mapWxtOptionsToRegisteredContentScript(
          entry.options,
          js,
          css
        )
      });
    });
  } else {
    server.reloadExtension();
  }
}
function reloadHtmlPages(groups, server) {
  const htmlEntries = groups.flat().filter(isHtmlEntrypoint);
  htmlEntries.forEach((entry) => {
    const path4 = getEntrypointBundlePath(entry, wxt.config.outDir, ".html");
    server.reloadPage(path4);
  });
  return {
    reloadedNames: htmlEntries.map((entry) => entry.name)
  };
}
function getFilenameList(names) {
  return names.map((name) => {
    return pc2.cyan(name);
  }).join(pc2.dim(", "));
}
function getExternalOutputDependencies(server) {
  return server.currentOutput?.steps.flatMap((step, i) => {
    if (Array.isArray(step.entrypoints) && i === 0) {
      return [];
    }
    return step.chunks.flatMap((chunk) => {
      if (chunk.type === "asset")
        return [];
      return chunk.moduleIds;
    });
  }).filter(
    (file) => !file.includes("node_modules") && !file.startsWith("\0")
  ).map(unnormalizePath).filter((file) => !file.startsWith(wxt.config.root)) ?? [];
}

// src/core/initialize.ts
import prompts from "prompts";
import { downloadTemplate } from "giget";
import fs2 from "fs-extra";
import path2 from "node:path";
import pc3 from "picocolors";
async function initialize(options) {
  consola.info("Initalizing new project");
  const templates = await listTemplates();
  const defaultTemplate = templates.find(
    (template) => template.name === options.template?.toLowerCase().trim()
  );
  const input = await prompts(
    [
      {
        name: "directory",
        type: () => options.directory == null ? "text" : void 0,
        message: "Project Directory",
        initial: options.directory
      },
      {
        name: "template",
        type: () => defaultTemplate == null ? "select" : void 0,
        message: "Choose a template",
        choices: templates.map((template) => ({
          title: TEMPLATE_COLORS[template.name]?.(template.name) ?? template.name,
          value: template
        }))
      },
      {
        name: "packageManager",
        type: () => options.packageManager == null ? "select" : void 0,
        message: "Package Manager",
        choices: [
          { title: pc3.red("npm"), value: "npm" },
          { title: pc3.yellow("pnpm"), value: "pnpm" },
          { title: pc3.cyan("yarn"), value: "yarn" },
          {
            title: `${pc3.magenta("bun")}${pc3.gray(" (experimental)")}`,
            value: "bun"
          }
        ]
      }
    ],
    {
      onCancel: () => process.exit(1)
    }
  );
  input.directory ??= options.directory;
  input.template ??= defaultTemplate;
  input.packageManager ??= options.packageManager;
  const isExists = await fs2.pathExists(input.directory);
  if (isExists) {
    const isEmpty = (await fs2.readdir(input.directory)).length === 0;
    if (!isEmpty) {
      consola.error(
        `The directory ${path2.resolve(input.directory)} is not empty. Aborted.`
      );
      process.exit(1);
    }
  }
  await cloneProject(input);
  const cdPath = path2.relative(process.cwd(), path2.resolve(input.directory));
  console.log();
  consola.log(
    `\u2728 WXT project created with the ${TEMPLATE_COLORS[input.template.name]?.(input.template.name) ?? input.template.name} template.`
  );
  console.log();
  consola.log("Next steps:");
  let step = 0;
  if (cdPath !== "")
    consola.log(`  ${++step}.`, pc3.cyan(`cd ${cdPath}`));
  consola.log(`  ${++step}.`, pc3.cyan(`${input.packageManager} install`));
  console.log();
}
async function listTemplates() {
  try {
    const res = await fetch("https://ungh.cc/repos/wxt-dev/wxt/files/main");
    if (res.status >= 300)
      throw Error(`Request failed with status ${res.status} ${res.statusText}`);
    const data = await res.json();
    return data.files.map((item) => item.path.match(/templates\/(.+)\/package\.json/)?.[1]).filter((name) => name != null).map((name) => ({ name, path: `templates/${name}` })).sort((l, r) => {
      const lWeight = TEMPLATE_SORT_WEIGHT[l.name] ?? Number.MAX_SAFE_INTEGER;
      const rWeight = TEMPLATE_SORT_WEIGHT[r.name] ?? Number.MAX_SAFE_INTEGER;
      const diff = lWeight - rWeight;
      if (diff !== 0)
        return diff;
      return l.name.localeCompare(r.name);
    });
  } catch (err) {
    consola.error(err);
    throw Error(`Failed to load templates`);
  }
}
async function cloneProject({
  directory,
  template,
  packageManager
}) {
  const { default: ora } = await import("ora");
  const spinner = ora("Downloading template").start();
  try {
    await downloadTemplate(`gh:wxt-dev/wxt/${template.path}`, {
      dir: directory,
      force: true
    });
    await fs2.move(
      path2.join(directory, "_gitignore"),
      path2.join(directory, ".gitignore")
    ).catch(
      (err) => consola.warn("Failed to move _gitignore to .gitignore:", err)
    );
    spinner.succeed();
  } catch (err) {
    spinner.fail();
    throw Error(`Failed to setup new project: ${JSON.stringify(err, null, 2)}`);
  }
}
var TEMPLATE_COLORS = {
  vanilla: pc3.blue,
  vue: pc3.green,
  react: pc3.cyan,
  svelte: pc3.red,
  solid: pc3.blue
};
var TEMPLATE_SORT_WEIGHT = {
  vanilla: 0,
  vue: 1,
  react: 2
};

// src/core/prepare.ts
async function prepare(config) {
  await registerWxt("build", config);
  wxt.logger.info("Generating types...");
  const entrypoints = await findEntrypoints();
  await generateTypesDir(entrypoints);
}

// src/core/zip.ts
import path3 from "node:path";
import fs3 from "fs-extra";
import { minimatch } from "minimatch";
import JSZip from "jszip";
import glob2 from "fast-glob";
async function zip(config) {
  await registerWxt("build", config);
  const output = await internalBuild();
  const start = Date.now();
  wxt.logger.info("Zipping extension...");
  const zipFiles = [];
  const projectName = wxt.config.zip.name ?? kebabCaseAlphanumeric(
    (await getPackageJson())?.name || path3.dirname(process.cwd())
  );
  const applyTemplate = (template) => template.replaceAll("{{name}}", projectName).replaceAll("{{browser}}", wxt.config.browser).replaceAll(
    "{{version}}",
    output.manifest.version_name ?? output.manifest.version
  ).replaceAll("{{mode}}", wxt.config.mode).replaceAll("{{manifestVersion}}", `mv${wxt.config.manifestVersion}`);
  await fs3.ensureDir(wxt.config.outBaseDir);
  const outZipFilename = applyTemplate(wxt.config.zip.artifactTemplate);
  const outZipPath = path3.resolve(wxt.config.outBaseDir, outZipFilename);
  await zipDir(wxt.config.outDir, outZipPath);
  zipFiles.push(outZipPath);
  if (wxt.config.browser === "firefox") {
    const { overrides, files: downloadedPackages } = await downloadPrivatePackages();
    const sourcesZipFilename = applyTemplate(wxt.config.zip.sourcesTemplate);
    const sourcesZipPath = path3.resolve(
      wxt.config.outBaseDir,
      sourcesZipFilename
    );
    await zipDir(wxt.config.zip.sourcesRoot, sourcesZipPath, {
      include: wxt.config.zip.includeSources,
      exclude: wxt.config.zip.excludeSources,
      transform(absolutePath, zipPath, content) {
        if (zipPath.endsWith("package.json")) {
          return addOverridesToPackageJson(absolutePath, content, overrides);
        }
      },
      additionalFiles: downloadedPackages
    });
    zipFiles.push(sourcesZipPath);
  }
  await printFileList(
    wxt.logger.success,
    `Zipped extension in ${formatDuration(Date.now() - start)}`,
    wxt.config.outBaseDir,
    zipFiles
  );
  return zipFiles;
}
async function zipDir(directory, outputPath, options) {
  const archive = new JSZip();
  const files = (await glob2("**/*", {
    cwd: directory,
    // Ignore node_modules, otherwise this glob step takes forever
    ignore: ["**/node_modules"],
    onlyFiles: true
  })).filter((relativePath) => {
    return wxt.config.zip.includeSources.some(
      (pattern) => minimatch(relativePath, pattern)
    ) || !wxt.config.zip.excludeSources.some(
      (pattern) => minimatch(relativePath, pattern)
    );
  });
  const filesToZip = [
    ...files,
    ...(options?.additionalFiles ?? []).map(
      (file) => path3.relative(directory, file)
    )
  ];
  for (const file of filesToZip) {
    const absolutePath = path3.resolve(directory, file);
    if (file.endsWith(".json")) {
      const content = await fs3.readFile(absolutePath, "utf-8");
      archive.file(
        file,
        await options?.transform?.(absolutePath, file, content) || content
      );
    } else {
      const content = await fs3.readFile(absolutePath);
      archive.file(file, content);
    }
  }
  await options?.additionalWork?.(archive);
  const buffer = await archive.generateAsync({
    type: "base64",
    ...wxt.config.zip.compressionLevel === 0 ? { compression: "STORE" } : {
      compression: "DEFLATE",
      compressionOptions: { level: wxt.config.zip.compressionLevel }
    }
  });
  await fs3.writeFile(outputPath, buffer, "base64");
}
async function downloadPrivatePackages() {
  const overrides = {};
  const files = [];
  if (wxt.config.zip.downloadPackages.length > 0) {
    const _downloadPackages = new Set(wxt.config.zip.downloadPackages);
    const allPackages = await wxt.pm.listDependencies({
      all: true,
      cwd: wxt.config.root
    });
    const downloadPackages = allPackages.filter(
      (pkg) => _downloadPackages.has(pkg.name)
    );
    for (const pkg of downloadPackages) {
      wxt.logger.info(`Downloading package: ${pkg.name}@${pkg.version}`);
      const id = `${pkg.name}@${pkg.version}`;
      const tgzPath = await wxt.pm.downloadDependency(
        id,
        wxt.config.zip.downloadedPackagesDir
      );
      files.push(tgzPath);
      overrides[id] = tgzPath;
    }
  }
  return { overrides, files };
}
function addOverridesToPackageJson(absolutePackageJsonPath, content, overrides) {
  if (Object.keys(overrides).length === 0)
    return content;
  const packageJsonDir = path3.dirname(absolutePackageJsonPath);
  const oldPackage = JSON.parse(content);
  const newPackage = {
    ...oldPackage,
    [wxt.pm.overridesKey]: { ...oldPackage[wxt.pm.overridesKey] }
  };
  Object.entries(overrides).forEach(([key, absolutePath]) => {
    newPackage[wxt.pm.overridesKey][key] = "file://./" + normalizePath(path3.relative(packageJsonDir, absolutePath));
  });
  return JSON.stringify(newPackage, null, 2);
}
export {
  build,
  clean,
  createServer,
  defineConfig,
  defineRunnerConfig,
  initialize,
  prepare,
  version,
  zip
};
