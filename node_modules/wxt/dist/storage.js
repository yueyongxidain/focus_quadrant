import {
  toArray
} from "./chunk-5X3S6AWF.js";
import "./chunk-VBXJIVYU.js";

// src/browser.ts
import originalBrowser from "webextension-polyfill";
var browser = originalBrowser;

// src/storage.ts
import { dequal } from "dequal/lite";

// src/sandbox/utils/logger.ts
function print(method, ...args) {
  if (import.meta.env.MODE === "production")
    return;
  if (typeof args[0] === "string") {
    const message = args.shift();
    method(`[wxt] ${message}`, ...args);
  } else {
    method("[wxt]", ...args);
  }
}
var logger = {
  debug: (...args) => print(console.debug, ...args),
  log: (...args) => print(console.log, ...args),
  warn: (...args) => print(console.warn, ...args),
  error: (...args) => print(console.error, ...args)
};

// src/storage.ts
var storage = createStorage();
function createStorage() {
  const drivers = {
    local: createDriver("local"),
    session: createDriver("session"),
    sync: createDriver("sync"),
    managed: createDriver("managed")
  };
  const getDriver = (area) => {
    const driver = drivers[area];
    if (driver == null) {
      const areaNames = Object.keys(drivers).join(", ");
      throw Error(`Invalid area "${area}". Options: ${areaNames}`);
    }
    return driver;
  };
  const resolveKey = (key) => {
    const deliminatorIndex = key.indexOf(":");
    const driverArea = key.substring(0, deliminatorIndex);
    const driverKey = key.substring(deliminatorIndex + 1);
    if (driverKey == null)
      throw Error(
        `Storage key should be in the form of "area:key", but received "${key}"`
      );
    return {
      driverArea,
      driverKey,
      driver: getDriver(driverArea)
    };
  };
  const getMetaKey = (key) => key + "$";
  const getValueOrDefault = (value, defaultValue) => value ?? defaultValue ?? null;
  const getMetaValue = (properties) => typeof properties === "object" && !Array.isArray(properties) ? properties : {};
  const getItem = async (driver, driverKey, opts) => {
    const res = await driver.getItem(driverKey);
    return getValueOrDefault(res, opts?.defaultValue);
  };
  const getMeta = async (driver, driverKey) => {
    const metaKey = getMetaKey(driverKey);
    const res = await driver.getItem(metaKey);
    return getMetaValue(res);
  };
  const setItem = async (driver, driverKey, value) => {
    await driver.setItem(driverKey, value ?? null);
  };
  const setMeta = async (driver, driverKey, properties) => {
    const metaKey = getMetaKey(driverKey);
    const existingFields = getMetaValue(await driver.getItem(metaKey));
    const newFields = { ...existingFields };
    Object.entries(properties).forEach(([key, value]) => {
      if (value == null) {
        delete newFields[key];
      } else {
        newFields[key] = value;
      }
    });
    await driver.setItem(metaKey, newFields);
  };
  const removeItem = async (driver, driverKey, opts) => {
    await driver.removeItem(driverKey);
    if (opts?.removeMeta) {
      const metaKey = getMetaKey(driverKey);
      await driver.removeItem(metaKey);
    }
  };
  const removeMeta = async (driver, driverKey, properties) => {
    const metaKey = getMetaKey(driverKey);
    if (properties == null) {
      await driver.removeItem(metaKey);
    } else {
      const newFields = getMetaValue(await driver.getItem(metaKey));
      toArray(properties).forEach((field) => delete newFields[field]);
      await driver.setItem(metaKey, newFields);
    }
  };
  const watch = (driver, driverKey, cb) => {
    return driver.watch(driverKey, cb);
  };
  const storage2 = {
    getItem: async (key, opts) => {
      const { driver, driverKey } = resolveKey(key);
      return await getItem(driver, driverKey, opts);
    },
    getItems: async (keys) => {
      const areaToKeyMap = /* @__PURE__ */ new Map();
      const keyToOptsMap = /* @__PURE__ */ new Map();
      keys.forEach((key) => {
        let keyStr;
        let opts;
        if (typeof key === "string") {
          keyStr = key;
        } else {
          keyStr = key.key;
          opts = key.options;
        }
        const { driverArea, driverKey } = resolveKey(keyStr);
        const keys2 = areaToKeyMap.get(driverArea) ?? [];
        areaToKeyMap.set(driverArea, keys2.concat(driverKey));
        keyToOptsMap.set(keyStr, opts);
      });
      const results = await Promise.all(
        Array.from(areaToKeyMap.entries()).map(async ([driverArea, keys2]) => {
          const driverResults = await drivers[driverArea].getItems(keys2);
          return driverResults.map((driverResult) => {
            const key = `${driverArea}:${driverResult.key}`;
            const value = getValueOrDefault(
              driverResult.value,
              keyToOptsMap.get(key)?.defaultValue
            );
            return { key, value };
          });
        })
      );
      return results.flat();
    },
    getMeta: async (key) => {
      const { driver, driverKey } = resolveKey(key);
      return await getMeta(driver, driverKey);
    },
    setItem: async (key, value) => {
      const { driver, driverKey } = resolveKey(key);
      await setItem(driver, driverKey, value);
    },
    setItems: async (values) => {
      const areaToKeyValueMap = /* @__PURE__ */ new Map();
      values.forEach(({ key, value }) => {
        const { driverArea, driverKey } = resolveKey(key);
        const values2 = areaToKeyValueMap.get(driverArea) ?? [];
        areaToKeyValueMap.set(
          driverArea,
          values2.concat({ key: driverKey, value })
        );
      });
      await Promise.all(
        Array.from(areaToKeyValueMap.entries()).map(
          async ([driverArea, values2]) => {
            const driver = getDriver(driverArea);
            await driver.setItems(values2);
          }
        )
      );
    },
    setMeta: async (key, properties) => {
      const { driver, driverKey } = resolveKey(key);
      await setMeta(driver, driverKey, properties);
    },
    removeItem: async (key, opts) => {
      const { driver, driverKey } = resolveKey(key);
      await removeItem(driver, driverKey, opts);
    },
    removeItems: async (keys) => {
      const areaToKeysMap = /* @__PURE__ */ new Map();
      keys.forEach((key) => {
        let keyStr;
        let opts;
        if (typeof key === "string") {
          keyStr = key;
        } else {
          keyStr = key.key;
          opts = key.options;
        }
        const { driverArea, driverKey } = resolveKey(keyStr);
        const areaKeys = areaToKeysMap.get(driverArea) ?? [];
        areaKeys.push(driverKey);
        if (opts?.removeMeta) {
          areaKeys.push(getMetaKey(driverKey));
        }
        areaToKeysMap.set(driverArea, areaKeys);
      });
      await Promise.all(
        Array.from(areaToKeysMap.entries()).map(async ([driverArea, keys2]) => {
          const driver = getDriver(driverArea);
          await driver.removeItems(keys2);
        })
      );
    },
    removeMeta: async (key, properties) => {
      const { driver, driverKey } = resolveKey(key);
      await removeMeta(driver, driverKey, properties);
    },
    snapshot: async (base, opts) => {
      const driver = getDriver(base);
      const data = await driver.snapshot();
      opts?.excludeKeys?.forEach((key) => {
        delete data[key];
        delete data[getMetaKey(key)];
      });
      return data;
    },
    restoreSnapshot: async (base, data) => {
      const driver = getDriver(base);
      await driver.restoreSnapshot(data);
    },
    watch: (key, cb) => {
      const { driver, driverKey } = resolveKey(key);
      return watch(driver, driverKey, cb);
    },
    unwatch() {
      Object.values(drivers).forEach((driver) => {
        driver.unwatch();
      });
    },
    defineItem: (key, opts) => {
      const { driver, driverKey } = resolveKey(key);
      const { version: targetVersion = 1, migrations = {} } = opts ?? {};
      if (targetVersion < 1) {
        throw Error(
          "Storage item version cannot be less than 1. Initial versions should be set to 1, not 0."
        );
      }
      const migrate = async () => {
        const driverMetaKey = getMetaKey(driverKey);
        const [{ value }, { value: meta }] = await driver.getItems([
          driverKey,
          driverMetaKey
        ]);
        if (value == null)
          return;
        const currentVersion = meta?.v ?? 1;
        if (currentVersion > targetVersion) {
          throw Error(
            `Version downgrade detected (v${currentVersion} -> v${targetVersion}) for "${key}"`
          );
        }
        logger.debug(
          `Running storage migration for ${key}: v${currentVersion} -> v${targetVersion}`
        );
        const migrationsToRun = Array.from(
          { length: targetVersion - currentVersion },
          (_, i) => currentVersion + i + 1
        );
        let migratedValue = value;
        for (const migrateToVersion of migrationsToRun) {
          migratedValue = await migrations?.[migrateToVersion]?.(migratedValue) ?? migratedValue;
        }
        await driver.setItems([
          { key: driverKey, value: migratedValue },
          { key: driverMetaKey, value: { ...meta, v: targetVersion } }
        ]);
        logger.debug(
          `Storage migration completed for ${key} v${targetVersion}`,
          { migratedValue }
        );
      };
      const migrationsDone = opts?.migrations == null ? Promise.resolve() : migrate().catch((err) => {
        logger.error(`Migration failed for ${key}`, err);
      });
      const getDefaultValue = () => opts?.defaultValue ?? null;
      return {
        get defaultValue() {
          return getDefaultValue();
        },
        getValue: async () => {
          await migrationsDone;
          return await getItem(driver, driverKey, opts);
        },
        getMeta: async () => {
          await migrationsDone;
          return await getMeta(driver, driverKey);
        },
        setValue: async (value) => {
          await migrationsDone;
          return await setItem(driver, driverKey, value);
        },
        setMeta: async (properties) => {
          await migrationsDone;
          return await setMeta(driver, driverKey, properties);
        },
        removeValue: async (opts2) => {
          await migrationsDone;
          return await removeItem(driver, driverKey, opts2);
        },
        removeMeta: async (properties) => {
          await migrationsDone;
          return await removeMeta(driver, driverKey, properties);
        },
        watch: (cb) => watch(
          driver,
          driverKey,
          (newValue, oldValue) => cb(newValue ?? getDefaultValue(), oldValue ?? getDefaultValue())
        ),
        migrate
      };
    }
  };
  return storage2;
}
function createDriver(storageArea) {
  const getStorageArea = () => {
    if (browser.runtime == null) {
      throw Error(
        [
          "'wxt/storage' must be loaded in a web extension environment",
          "\n - If thrown during a build, see https://github.com/wxt-dev/wxt/issues/371",
          " - If thrown during tests, mock 'wxt/browser' correctly. See https://wxt.dev/guide/testing.html\n"
        ].join("\n")
      );
    }
    if (browser.storage == null) {
      throw Error(
        "You must add the 'storage' permission to your manifest to use 'wxt/storage'"
      );
    }
    const area = browser.storage[storageArea];
    if (area == null)
      throw Error(`"browser.storage.${storageArea}" is undefined`);
    return area;
  };
  const watchListeners = /* @__PURE__ */ new Set();
  return {
    getItem: async (key) => {
      const res = await getStorageArea().get(key);
      return res[key];
    },
    getItems: async (keys) => {
      const result = await getStorageArea().get(keys);
      return keys.map((key) => ({ key, value: result[key] ?? null }));
    },
    setItem: async (key, value) => {
      if (value == null) {
        await getStorageArea().remove(key);
      } else {
        await getStorageArea().set({ [key]: value });
      }
    },
    setItems: async (values) => {
      const map = values.reduce(
        (map2, { key, value }) => {
          map2[key] = value;
          return map2;
        },
        {}
      );
      await getStorageArea().set(map);
    },
    removeItem: async (key) => {
      await getStorageArea().remove(key);
    },
    removeItems: async (keys) => {
      await getStorageArea().remove(keys);
    },
    snapshot: async () => {
      return await getStorageArea().get();
    },
    restoreSnapshot: async (data) => {
      await getStorageArea().set(data);
    },
    watch(key, cb) {
      const listener = (changes) => {
        const change = changes[key];
        if (change == null)
          return;
        if (dequal(change.newValue, change.oldValue))
          return;
        cb(change.newValue ?? null, change.oldValue ?? null);
      };
      getStorageArea().onChanged.addListener(listener);
      watchListeners.add(listener);
      return () => {
        getStorageArea().onChanged.removeListener(listener);
        watchListeners.delete(listener);
      };
    },
    unwatch() {
      watchListeners.forEach((listener) => {
        getStorageArea().onChanged.removeListener(listener);
      });
      watchListeners.clear();
    }
  };
}
export {
  storage
};
