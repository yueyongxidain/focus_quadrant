import { Manifest } from 'webextension-polyfill';

declare class WxtLocationChangeEvent extends Event {
    readonly newUrl: URL;
    readonly oldUrl: URL;
    static EVENT_NAME: string;
    constructor(newUrl: URL, oldUrl: URL);
}

/**
 * Implements [`AbortController`](https://developer.mozilla.org/en-US/docs/Web/API/AbortController).
 * Used to detect and stop content script code when the script is invalidated.
 *
 * It also provides several utilities like `ctx.setTimeout` and `ctx.setInterval` that should be used in
 * content scripts instead of `window.setTimeout` or `window.setInterval`.
 *
 * To create context for testing, you can use the class's constructor:
 *
 * ```ts
 * import { ContentScriptContext } from 'wxt/client';
 *
 * test("storage listener should be removed when context is invalidated", () => {
 *   const ctx = new ContentScriptContext('test');
 *   const item = storage.defineItem("local:count", { defaultValue: 0 });
 *   const watcher = vi.fn();
 *
 *   const unwatch = item.watch(watcher);
 *   ctx.onInvalidated(unwatch); // Listen for invalidate here
 *
 *   await item.setValue(1);
 *   expect(watcher).toBeCalledTimes(1);
 *   expect(watcher).toBeCalledWith(1, 0);
 *
 *   ctx.notifyInvalidated(); // Use this function to invalidate the context
 *   await item.setValue(2);
 *   expect(watcher).toBeCalledTimes(1);
 * });
 * ```
 */
declare class ContentScriptContext implements AbortController {
    #private;
    private readonly contentScriptName;
    readonly options?: Omit<ContentScriptDefinition, "main"> | undefined;
    private static SCRIPT_STARTED_MESSAGE_TYPE;
    constructor(contentScriptName: string, options?: Omit<ContentScriptDefinition, "main"> | undefined);
    get signal(): AbortSignal;
    abort(reason?: any): void;
    get isInvalid(): boolean;
    get isValid(): boolean;
    /**
     * Add a listener that is called when the content script's context is invalidated.
     *
     * @returns A function to remove the listener.
     *
     * @example
     * browser.runtime.onMessage.addListener(cb);
     * const removeInvalidatedListener = ctx.onInvalidated(() => {
     *   browser.runtime.onMessage.removeListener(cb);
     * })
     * // ...
     * removeInvalidatedListener();
     */
    onInvalidated(cb: () => void): () => void;
    /**
     * Return a promise that never resolves. Useful if you have an async function that shouldn't run
     * after the context is expired.
     *
     * @example
     * const getValueFromStorage = async () => {
     *   if (ctx.isInvalid) return ctx.block();
     *
     *   // ...
     * }
     */
    block<T>(): Promise<T>;
    /**
     * Wrapper around `window.setInterval` that automatically clears the interval when invalidated.
     */
    setInterval(handler: () => void, timeout?: number): number;
    /**
     * Wrapper around `window.setTimeout` that automatically clears the interval when invalidated.
     */
    setTimeout(handler: () => void, timeout?: number): number;
    /**
     * Wrapper around `window.requestAnimationFrame` that automatically cancels the request when
     * invalidated.
     */
    requestAnimationFrame(callback: FrameRequestCallback): number;
    /**
     * Wrapper around `window.requestIdleCallback` that automatically cancels the request when
     * invalidated.
     */
    requestIdleCallback(callback: IdleRequestCallback, options?: IdleRequestOptions): number;
    /**
     * Call `target.addEventListener` and remove the event listener when the context is invalidated.
     *
     * Includes additional events useful for content scripts:
     *
     * - `"wxt:locationchange"` - Triggered when HTML5 history mode is used to change URL. Content
     *   scripts are not reloaded when navigating this way, so this can be used to reset the content
     *   script state on URL change, or run custom code.
     *
     * @example
     * ctx.addEventListener(document, "visibilitychange", () => {
     *   // ...
     * });
     * ctx.addEventListener(document, "wxt:locationchange", () => {
     *   // ...
     * });
     */
    addEventListener<TTarget extends EventTarget, TType extends keyof WxtContentScriptEventMap>(target: TTarget, type: TType, handler: (event: WxtContentScriptEventMap[TType]) => void, options?: AddEventListenerOptions): void;
    /**
     * @internal
     * Abort the abort controller and execute all `onInvalidated` listeners.
     */
    notifyInvalidated(): void;
}
interface WxtContentScriptEventMap extends WindowEventMap {
    'wxt:locationchange': WxtLocationChangeEvent;
}

type TargetBrowser = string;
interface BaseEntrypointOptions {
    /**
     * List of target browsers to include this entrypoint in. Defaults to being included in all
     * builds. Cannot be used with `exclude`. You must choose one of the two options.
     *
     * @default undefined
     */
    include?: TargetBrowser[];
    /**
     * List of target browsers to exclude this entrypoint from. Cannot be used with `include`. You
     * must choose one of the two options.
     *
     * @default undefined
     */
    exclude?: TargetBrowser[];
}
interface BackgroundEntrypointOptions extends BaseEntrypointOptions {
    persistent?: PerBrowserOption<boolean>;
    /**
     * Set to `"module"` to output the background entrypoint as ESM. ESM outputs can share chunks and
     * reduce the overall size of the bundled extension.
     *
     * When `undefined`, the background is bundled individually into an IIFE format.
     *
     * @default undefined
     */
    type?: PerBrowserOption<'module'>;
}
interface BaseContentScriptEntrypointOptions extends BaseEntrypointOptions {
    matches: PerBrowserOption<Manifest.ContentScript['matches']>;
    /**
     * See https://developer.chrome.com/docs/extensions/mv3/content_scripts/
     * @default "documentIdle"
     */
    runAt?: PerBrowserOption<Manifest.ContentScript['run_at']>;
    /**
     * See https://developer.chrome.com/docs/extensions/mv3/content_scripts/
     * @default false
     */
    matchAboutBlank?: PerBrowserOption<Manifest.ContentScript['match_about_blank']>;
    /**
     * See https://developer.chrome.com/docs/extensions/mv3/content_scripts/
     * @default []
     */
    excludeMatches?: PerBrowserOption<Manifest.ContentScript['exclude_matches']>;
    /**
     * See https://developer.chrome.com/docs/extensions/mv3/content_scripts/
     * @default []
     */
    includeGlobs?: PerBrowserOption<Manifest.ContentScript['include_globs']>;
    /**
     * See https://developer.chrome.com/docs/extensions/mv3/content_scripts/
     * @default []
     */
    excludeGlobs?: PerBrowserOption<Manifest.ContentScript['exclude_globs']>;
    /**
     * See https://developer.chrome.com/docs/extensions/mv3/content_scripts/
     * @default false
     */
    allFrames?: PerBrowserOption<Manifest.ContentScript['all_frames']>;
    /**
     * See https://developer.chrome.com/docs/extensions/mv3/content_scripts/
     * @default false
     */
    matchOriginAsFallback?: PerBrowserOption<boolean>;
    /**
     * Customize how imported/generated styles are injected with the content script. Regardless of the
     * mode selected, CSS will always be built and included in the output directory.
     *
     * - `"manifest"` - Include the CSS in the manifest, under the content script's `css` array.
     * - `"manual"` - Exclude the CSS from the manifest. You are responsible for manually loading it
     *   onto the page. Use `browser.runtime.getURL("content-scripts/<name>.css")` to get the file's
     *   URL
     * - `"ui"` - Exclude the CSS from the manifest. CSS will be automatically added to your UI when
     *   calling `createShadowRootUi`
     *
     * @default "manifest"
     */
    cssInjectionMode?: PerBrowserOption<'manifest' | 'manual' | 'ui'>;
    /**
     * Specify how the content script is registered.
     *
     * - `"manifest"`: The content script will be added to the `content_scripts` entry in the
     *   manifest. This is the normal and most well known way of registering a content script.
     * - `"runtime"`: The content script's `matches` is added to `host_permissions` and you are
     *   responsible for using the scripting API to register/execute the content script
     *   dynamically at runtime.
     *
     * @default "manifest"
     */
    registration?: PerBrowserOption<'manifest' | 'runtime'>;
}
interface MainWorldContentScriptEntrypointOptions extends BaseContentScriptEntrypointOptions {
    /**
     * See https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts#isolated_world
     */
    world: 'MAIN';
}
interface IsolatedWorldContentScriptEntrypointOptions extends BaseContentScriptEntrypointOptions {
    /**
     * See https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts#isolated_world
     * @default "ISOLATED"
     */
    world?: 'ISOLATED';
}
interface IsolatedWorldContentScriptDefinition extends IsolatedWorldContentScriptEntrypointOptions {
    /**
     * Main function executed when the content script is loaded.
     *
     * When running a content script with `browser.scripting.executeScript`,
     * values returned from this function will be returned in the `executeScript`
     * result as well. Otherwise returning a value does nothing.
     */
    main(ctx: ContentScriptContext): any | Promise<any>;
}
interface MainWorldContentScriptDefinition extends MainWorldContentScriptEntrypointOptions {
    /**
     * Main function executed when the content script is loaded.
     *
     * When running a content script with `browser.scripting.executeScript`,
     * values returned from this function will be returned in the `executeScript`
     * result as well. Otherwise returning a value does nothing.
     */
    main(): any | Promise<any>;
}
type ContentScriptDefinition = IsolatedWorldContentScriptDefinition | MainWorldContentScriptDefinition;
interface BackgroundDefinition extends BackgroundEntrypointOptions {
    /**
     * Main function executed when the background script is started. Cannot be async.
     */
    main(): void;
}
interface UnlistedScriptDefinition extends BaseEntrypointOptions {
    /**
     * Main function executed when the unlisted script is ran.
     *
     * When running a content script with `browser.scripting.executeScript`,
     * values returned from this function will be returned in the `executeScript`
     * result as well. Otherwise returning a value does nothing.
     */
    main(): any | Promise<any>;
}
/**
 * Either a single value or a map of different browsers to the value for that browser.
 */
type PerBrowserOption<T> = T | PerBrowserMap<T>;
type PerBrowserMap<T> = {
    [browser: TargetBrowser]: T;
};

export { type BackgroundDefinition as B, type ContentScriptDefinition as C, type UnlistedScriptDefinition as U, ContentScriptContext as a };
