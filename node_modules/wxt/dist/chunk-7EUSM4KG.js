import {
  every,
  some,
  toArray
} from "./chunk-5X3S6AWF.js";
import {
  LogLevels,
  consola
} from "./chunk-ZZCTFNQ5.js";
import {
  __require
} from "./chunk-VBXJIVYU.js";

// package.json
var version = "0.18.1";

// src/core/utils/paths.ts
import systemPath from "node:path";
import normalize from "normalize-path";
function normalizePath(path8) {
  return normalize(path8);
}
function unnormalizePath(path8) {
  return systemPath.normalize(path8);
}
var CSS_EXTENSIONS = ["css", "scss", "sass", "less", "styl", "stylus"];
var CSS_EXTENSIONS_PATTERN = `+(${CSS_EXTENSIONS.join("|")})`;

// src/core/utils/entrypoints.ts
import path, { relative, resolve } from "node:path";
function getEntrypointName(entrypointsDir, inputPath) {
  const relativePath = path.relative(entrypointsDir, inputPath);
  const name = relativePath.split(/[\.\/\\]/, 2)[0];
  return name;
}
function getEntrypointOutputFile(entrypoint, ext) {
  return resolve(entrypoint.outputDir, `${entrypoint.name}${ext}`);
}
function getEntrypointBundlePath(entrypoint, outDir, ext) {
  return normalizePath(
    relative(outDir, getEntrypointOutputFile(entrypoint, ext))
  );
}
function resolvePerBrowserOption(option, browser) {
  if (typeof option === "object" && !Array.isArray(option))
    return option[browser];
  return option;
}
function resolvePerBrowserOptions(options, browser) {
  return Object.fromEntries(
    Object.entries(options).map(([key, value]) => [
      key,
      key === "defaultIcon" ? value : resolvePerBrowserOption(value, browser)
    ])
  );
}
function isHtmlEntrypoint(entrypoint) {
  return entrypoint.inputPath.endsWith(".html");
}

// src/core/utils/time.ts
function formatDuration(duration) {
  if (duration < 1e3)
    return `${duration} ms`;
  if (duration < 1e4)
    return `${(duration / 1e3).toFixed(3)} s`;
  if (duration < 6e4)
    return `${(duration / 1e3).toFixed(1)} s`;
  return `${(duration / 1e3).toFixed(0)} s`;
}
function withTimeout(promise, duration) {
  return new Promise((res, rej) => {
    const timeout = setTimeout(() => {
      rej(`Promise timed out after ${duration}ms`);
    }, duration);
    promise.then(res).catch(rej).finally(() => clearTimeout(timeout));
  });
}

// src/core/utils/network.ts
import dns from "node:dns";
function isOffline() {
  const isOffline2 = new Promise((res) => {
    dns.resolve("google.com", (err) => {
      if (err == null) {
        res(false);
      } else {
        res(true);
      }
    });
  });
  return withTimeout(isOffline2, 1e3).catch(() => true);
}
async function isOnline() {
  const offline = await isOffline();
  return !offline;
}
async function fetchCached(url, config) {
  let content = "";
  if (await isOnline()) {
    const res = await fetch(url);
    if (res.status < 300) {
      content = await res.text();
      await config.fsCache.set(url, content);
    } else {
      config.logger.debug(
        `Failed to download "${url}", falling back to cache...`
      );
    }
  }
  if (!content)
    content = await config.fsCache.get(url) ?? "";
  if (!content)
    throw Error(
      `Offline and "${url}" has not been cached. Try again when online.`
    );
  return content;
}

// src/core/builders/vite/plugins/download.ts
function download(config) {
  return {
    name: "wxt:download",
    resolveId(id) {
      if (id.startsWith("url:"))
        return "\0" + id;
    },
    async load(id) {
      if (!id.startsWith("\0url:"))
        return;
      const url = id.replace("\0url:", "");
      return await fetchCached(url, config);
    }
  };
}

// src/core/builders/vite/plugins/unimport.ts
import { createUnimport } from "unimport";
import { extname } from "path";
var ENABLED_EXTENSIONS = /* @__PURE__ */ new Set([
  ".js",
  ".jsx",
  ".ts",
  ".tsx",
  ".vue",
  ".svelte"
]);
function unimport(config) {
  const options = config.imports;
  if (options === false)
    return [];
  const unimport2 = createUnimport(options);
  return {
    name: "wxt:unimport",
    async config() {
      await unimport2.scanImportsFromDir(void 0, { cwd: config.srcDir });
    },
    async transform(code, id) {
      if (id.includes("node_modules"))
        return;
      if (!ENABLED_EXTENSIONS.has(extname(id)))
        return;
      const injected = await unimport2.injectImports(code, id);
      return {
        code: injected.code,
        map: injected.s.generateMap({ hires: "boundary", source: id })
      };
    }
  };
}

// src/core/builders/vite/plugins/tsconfigPaths.ts
function tsconfigPaths(config) {
  return {
    name: "wxt:aliases",
    async config() {
      return {
        resolve: {
          alias: config.alias
        }
      };
    }
  };
}

// src/core/utils/globals.ts
function getGlobals(config) {
  return [
    {
      name: "MANIFEST_VERSION",
      value: config.manifestVersion,
      type: `2 | 3`
    },
    {
      name: "BROWSER",
      value: config.browser,
      type: `string`
    },
    {
      name: "CHROME",
      value: config.browser === "chrome",
      type: `boolean`
    },
    {
      name: "FIREFOX",
      value: config.browser === "firefox",
      type: `boolean`
    },
    {
      name: "SAFARI",
      value: config.browser === "safari",
      type: `boolean`
    },
    {
      name: "EDGE",
      value: config.browser === "edge",
      type: `boolean`
    },
    {
      name: "OPERA",
      value: config.browser === "opera",
      type: `boolean`
    },
    {
      name: "COMMAND",
      value: config.command,
      type: `"build" | "serve"`
    }
  ];
}
function getEntrypointGlobals(entrypointName) {
  return [
    {
      name: "ENTRYPOINT",
      value: entrypointName,
      type: `string`
    }
  ];
}

// src/core/builders/vite/plugins/globals.ts
function globals(config) {
  return {
    name: "wxt:globals",
    config() {
      const define = {};
      for (const global of getGlobals(config)) {
        define[`import.meta.env.${global.name}`] = JSON.stringify(global.value);
      }
      return {
        define
      };
    }
  };
}

// src/core/builders/vite/plugins/webextensionPolyfillMock.ts
import path2 from "node:path";
function webextensionPolyfillMock(config) {
  return {
    name: "wxt:testing-inline-deps",
    config() {
      return {
        resolve: {
          alias: {
            // Alias to use a mocked version of the polyfill
            "webextension-polyfill": path2.resolve(
              config.wxtModuleDir,
              "dist/virtual/mock-browser"
            )
          }
        },
        ssr: {
          // Inline all WXT modules
          noExternal: ["wxt"]
        }
      };
    }
  };
}

// src/core/builders/vite/plugins/devHtmlPrerender.ts
import { parseHTML } from "linkedom";
import { dirname, relative as relative2, resolve as resolve2 } from "node:path";
var reactRefreshPreamble = "";
function devHtmlPrerender(config, server) {
  const htmlReloadId = "@wxt/reload-html";
  const resolvedHtmlReloadId = resolve2(
    config.wxtModuleDir,
    "dist/virtual/reload-html.js"
  );
  const virtualReactRefreshId = "@wxt/virtual-react-refresh";
  const resolvedVirtualReactRefreshId = "\0" + virtualReactRefreshId;
  return [
    {
      apply: "build",
      name: "wxt:dev-html-prerender",
      config() {
        return {
          resolve: {
            alias: {
              [htmlReloadId]: resolvedHtmlReloadId
            }
          }
        };
      },
      // Convert scripts like src="./main.tsx" -> src="http://localhost:3000/entrypoints/popup/main.tsx"
      // before the paths are replaced with their bundled path
      transform(code, id) {
        if (config.command !== "serve" || server == null || !id.endsWith(".html"))
          return;
        const { document } = parseHTML(code);
        const _pointToDevServer = (querySelector, attr) => pointToDevServer(config, server, id, document, querySelector, attr);
        _pointToDevServer("script[type=module]", "src");
        _pointToDevServer("link[rel=stylesheet]", "href");
        const reloader = document.createElement("script");
        reloader.src = htmlReloadId;
        reloader.type = "module";
        document.head.appendChild(reloader);
        const newHtml = document.toString();
        config.logger.debug("transform " + id);
        config.logger.debug("Old HTML:\n" + code);
        config.logger.debug("New HTML:\n" + newHtml);
        return newHtml;
      },
      // Pass the HTML through the dev server to add dev-mode specific code
      async transformIndexHtml(html, ctx) {
        if (config.command !== "serve" || server == null)
          return;
        const originalUrl = `${server.origin}${ctx.path}`;
        const name = getEntrypointName(config.entrypointsDir, ctx.filename);
        const url = `${server.origin}/${name}.html`;
        const serverHtml = await server.transformHtml(url, html, originalUrl);
        const { document } = parseHTML(serverHtml);
        const reactRefreshScript = Array.from(
          document.querySelectorAll("script[type=module]")
        ).find((script) => script.innerHTML.includes("@react-refresh"));
        if (reactRefreshScript) {
          reactRefreshPreamble = reactRefreshScript.innerHTML;
          const virtualScript = document.createElement("script");
          virtualScript.type = "module";
          virtualScript.src = `${server.origin}/${virtualReactRefreshId}`;
          reactRefreshScript.replaceWith(virtualScript);
        }
        const viteClientScript = document.querySelector(
          "script[src='/@vite/client']"
        );
        if (viteClientScript) {
          viteClientScript.src = `${server.origin}${viteClientScript.src}`;
        }
        const newHtml = document.toString();
        config.logger.debug("transformIndexHtml " + ctx.filename);
        config.logger.debug("Old HTML:\n" + html);
        config.logger.debug("New HTML:\n" + newHtml);
        return newHtml;
      }
    },
    {
      name: "wxt:virtualize-react-refresh",
      apply: "serve",
      resolveId(id) {
        if (id === `/${virtualReactRefreshId}`) {
          return resolvedVirtualReactRefreshId;
        }
        if (id.startsWith("/chunks/")) {
          return "\0noop";
        }
      },
      load(id) {
        if (id === resolvedVirtualReactRefreshId) {
          return reactRefreshPreamble;
        }
        if (id === "\0noop") {
          return "";
        }
      }
    }
  ];
}
function pointToDevServer(config, server, id, document, querySelector, attr) {
  document.querySelectorAll(querySelector).forEach((element) => {
    const src = element.getAttribute(attr);
    if (!src || isUrl(src))
      return;
    let resolvedAbsolutePath;
    const matchingAlias = Object.entries(config.alias).find(
      ([key]) => src.startsWith(key)
    );
    if (matchingAlias) {
      const [alias, replacement] = matchingAlias;
      resolvedAbsolutePath = resolve2(
        config.root,
        src.replace(alias, replacement)
      );
    } else {
      resolvedAbsolutePath = resolve2(dirname(id), src);
    }
    if (resolvedAbsolutePath) {
      const relativePath = normalizePath(
        relative2(config.root, resolvedAbsolutePath)
      );
      if (relativePath.startsWith(".")) {
        let path8 = normalizePath(resolvedAbsolutePath);
        if (!path8.startsWith("/"))
          path8 = "/" + path8;
        element.setAttribute(attr, `${server.origin}/@fs${path8}`);
      } else {
        const url = new URL(relativePath, server.origin);
        element.setAttribute(attr, url.href);
      }
    }
  });
}
function isUrl(str) {
  try {
    new URL(str);
    return true;
  } catch {
    return false;
  }
}

// src/core/builders/vite/plugins/devServerGlobals.ts
function devServerGlobals(config, server) {
  return {
    name: "wxt:dev-server-globals",
    config() {
      if (server == null || config.command == "build")
        return;
      return {
        define: {
          __DEV_SERVER_PROTOCOL__: JSON.stringify("ws:"),
          __DEV_SERVER_HOSTNAME__: JSON.stringify(server.hostname),
          __DEV_SERVER_PORT__: JSON.stringify(server.port)
        }
      };
    }
  };
}

// src/core/builders/vite/plugins/multipageMove.ts
import { dirname as dirname2, extname as extname2, resolve as resolve3, join } from "node:path";
import fs, { ensureDir } from "fs-extra";
function multipageMove(entrypoints, config) {
  return {
    name: "wxt:multipage-move",
    async writeBundle(_, bundle) {
      for (const oldBundlePath in bundle) {
        const entrypoint = entrypoints.find(
          (entry) => !!normalizePath(entry.inputPath).endsWith(oldBundlePath)
        );
        if (entrypoint == null) {
          config.logger.debug(
            `No entrypoint found for ${oldBundlePath}, leaving in chunks directory`
          );
          continue;
        }
        const newBundlePath = getEntrypointBundlePath(
          entrypoint,
          config.outDir,
          extname2(oldBundlePath)
        );
        if (newBundlePath === oldBundlePath) {
          config.logger.debug(
            "HTML file is already in the correct location",
            oldBundlePath
          );
          continue;
        }
        const oldAbsPath = resolve3(config.outDir, oldBundlePath);
        const newAbsPath = resolve3(config.outDir, newBundlePath);
        await ensureDir(dirname2(newAbsPath));
        await fs.move(oldAbsPath, newAbsPath, { overwrite: true });
        const renamedChunk = {
          ...bundle[oldBundlePath],
          fileName: newBundlePath
        };
        delete bundle[oldBundlePath];
        bundle[newBundlePath] = renamedChunk;
      }
      removeEmptyDirs(config.outDir);
    }
  };
}
async function removeEmptyDirs(dir) {
  const files = await fs.readdir(dir);
  for (const file of files) {
    const filePath = join(dir, file);
    const stats = await fs.stat(filePath);
    if (stats.isDirectory()) {
      await removeEmptyDirs(filePath);
    }
  }
  try {
    await fs.rmdir(dir);
  } catch {
  }
}

// src/core/utils/virtual-modules.ts
var virtualEntrypointTypes = [
  "content-script-main-world",
  "content-script-isolated-world",
  "background",
  "unlisted-script"
];
var virtualEntrypointModuleNames = virtualEntrypointTypes.map(
  (name) => `${name}-entrypoint`
);
var virtualModuleNames = [
  ...virtualEntrypointModuleNames,
  "mock-browser",
  "reload-html"
];

// src/core/builders/vite/plugins/resolveVirtualModules.ts
import fs2 from "fs-extra";
import { resolve as resolve4 } from "path";
function resolveVirtualModules(config) {
  return virtualModuleNames.map((name) => {
    const virtualId = `virtual:wxt-${name}?`;
    const resolvedVirtualId = "\0" + virtualId;
    return {
      name: `wxt:resolve-virtual-${name}`,
      resolveId(id) {
        const index = id.indexOf(virtualId);
        if (index === -1)
          return;
        const inputPath = normalizePath(id.substring(index + virtualId.length));
        return resolvedVirtualId + inputPath;
      },
      async load(id) {
        if (!id.startsWith(resolvedVirtualId))
          return;
        const inputPath = id.replace(resolvedVirtualId, "");
        const template = await fs2.readFile(
          resolve4(config.wxtModuleDir, `dist/virtual/${name}.js`),
          "utf-8"
        );
        return template.replace(`virtual:user-${name}`, inputPath);
      }
    };
  });
}

// src/core/utils/constants.ts
var VIRTUAL_NOOP_BACKGROUND_MODULE_ID = "virtual:user-background";

// src/core/builders/vite/plugins/noopBackground.ts
function noopBackground() {
  const virtualModuleId = VIRTUAL_NOOP_BACKGROUND_MODULE_ID;
  const resolvedVirtualModuleId = "\0" + virtualModuleId;
  return {
    name: "wxt:noop-background",
    resolveId(id) {
      if (id === virtualModuleId)
        return resolvedVirtualModuleId;
    },
    load(id) {
      if (id === resolvedVirtualModuleId) {
        return `import { defineBackground } from 'wxt/sandbox';
export default defineBackground(() => void 0)`;
      }
    }
  };
}

// src/core/builders/vite/plugins/cssEntrypoints.ts
function cssEntrypoints(entrypoint, config) {
  return {
    name: "wxt:css-entrypoint",
    config() {
      return {
        build: {
          rollupOptions: {
            output: {
              assetFileNames: () => getEntrypointBundlePath(entrypoint, config.outDir, ".css")
            }
          }
        }
      };
    },
    generateBundle(_, bundle) {
      Object.keys(bundle).forEach((file) => {
        if (file.endsWith(".js"))
          delete bundle[file];
      });
    }
  };
}

// src/core/builders/vite/plugins/bundleAnalysis.ts
import { visualizer } from "@aklinker1/rollup-plugin-visualizer";
import path3 from "node:path";
var increment = 0;
function bundleAnalysis(config) {
  return visualizer({
    template: "raw-data",
    filename: path3.resolve(
      config.analysis.outputDir,
      `${config.analysis.outputName}-${increment++}.json`
    )
  });
}

// src/core/builders/vite/plugins/excludeBrowserPolyfill.ts
function excludeBrowserPolyfill(config) {
  const virtualId = "virtual:wxt-webextension-polyfill-disabled";
  return {
    name: "wxt:exclude-browser-polyfill",
    config() {
      if (config.experimental.includeBrowserPolyfill)
        return;
      return {
        resolve: {
          alias: {
            "webextension-polyfill": virtualId
          }
        }
      };
    },
    load(id) {
      if (id === virtualId) {
        return "export default chrome";
      }
    }
  };
}

// src/core/builders/vite/plugins/entrypointGroupGlobals.ts
function entrypointGroupGlobals(entrypointGroup) {
  return {
    name: "wxt:entrypoint-group-globals",
    config() {
      const define = {};
      let name = Array.isArray(entrypointGroup) ? "html" : entrypointGroup.name;
      for (const global of getEntrypointGlobals(name)) {
        define[`import.meta.env.${global.name}`] = JSON.stringify(global.value);
      }
      return {
        define
      };
    }
  };
}

// src/core/builders/vite/plugins/defineImportMeta.ts
function defineImportMeta() {
  return {
    name: "wxt:define",
    config() {
      return {
        define: {
          // This works for all extension contexts, including background service worker
          "import.meta.url": "self.location.href"
        }
      };
    }
  };
}

// src/core/utils/transform.ts
import { parseModule } from "magicast";
function removeMainFunctionCode(code) {
  const mod = parseModule(code);
  emptyMainFunction(mod);
  return mod.generate();
}
function emptyMainFunction(mod) {
  if (mod.exports?.default?.$type === "function-call") {
    if (mod.exports.default.$ast?.arguments?.[0]?.body) {
      mod.exports.default.$ast.arguments[0].body.body = [];
    } else if (mod.exports.default.$ast?.arguments?.[0]?.properties) {
      mod.exports.default.$ast.arguments[0].properties = mod.exports.default.$ast.arguments[0].properties.filter(
        (prop) => prop.key.name !== "main"
      );
    }
  }
}

// src/core/builders/vite/plugins/removeEntrypointMainFunction.ts
import { resolve as resolve5 } from "node:path";
function removeEntrypointMainFunction(config, path8) {
  const absPath = normalizePath(resolve5(config.root, path8));
  return {
    name: "wxt:remove-entrypoint-main-function",
    transform(code, id) {
      if (id === absPath)
        return removeMainFunctionCode(code);
    }
  };
}

// src/core/utils/strings.ts
function kebabCaseAlphanumeric(str) {
  return str.toLowerCase().replace(/[^a-z0-9-\s]/g, "").replace(/\s+/g, "-");
}
function safeVarName(str) {
  return "_" + kebabCaseAlphanumeric(str.trim()).replace("-", "_");
}
function removeImportStatements(text) {
  return text.replace(
    /(import\s?[{\w][\s\S]*?from\s?["'][\s\S]*?["'];?|import\s?["'][\s\S]*?["'];?)/gm,
    ""
  );
}
function removeProjectImportStatements(text) {
  const noImports = removeImportStatements(text);
  return `import { defineUnlistedScript, defineContentScript, defineBackground } from 'wxt/sandbox';

${noImports}`;
}

// src/core/utils/fs.ts
import fs3 from "fs-extra";
import glob from "fast-glob";
async function writeFileIfDifferent(file, newContents) {
  const existingContents = await fs3.readFile(file, "utf-8").catch(() => void 0);
  if (existingContents !== newContents) {
    await fs3.writeFile(file, newContents);
  }
}
async function getPublicFiles() {
  if (!await fs3.exists(wxt.config.publicDir))
    return [];
  const files = await glob("**/*", { cwd: wxt.config.publicDir });
  return files.map(unnormalizePath);
}

// src/core/utils/building/build-entrypoints.ts
import fs4 from "fs-extra";
import { dirname as dirname3, resolve as resolve6 } from "path";
import pc from "picocolors";
async function buildEntrypoints(groups, spinner) {
  const steps = [];
  for (let i = 0; i < groups.length; i++) {
    const group = groups[i];
    const groupNames = toArray(group).map((e) => e.name);
    const groupNameColored = groupNames.join(pc.dim(", "));
    spinner.text = pc.dim(`[${i + 1}/${groups.length}]`) + ` ${groupNameColored}`;
    try {
      steps.push(await wxt.builder.build(group));
    } catch (err) {
      spinner.stop().clear();
      wxt.logger.error(err);
      throw Error(`Failed to build ${groupNames.join(", ")}`, { cause: err });
    }
  }
  const publicAssets = await copyPublicDirectory();
  return { publicAssets, steps };
}
async function copyPublicDirectory() {
  const files = await getPublicFiles();
  if (files.length === 0)
    return [];
  const publicAssets = [];
  for (const file of files) {
    const srcPath = resolve6(wxt.config.publicDir, file);
    const outPath = resolve6(wxt.config.outDir, file);
    await fs4.ensureDir(dirname3(outPath));
    await fs4.copyFile(srcPath, outPath);
    publicAssets.push({
      type: "asset",
      fileName: file
    });
  }
  return publicAssets;
}

// src/core/utils/building/detect-dev-changes.ts
function detectDevChanges(changedFiles, currentOutput) {
  const isConfigChange = some(
    changedFiles,
    (file) => file === wxt.config.userConfigMetadata.configFile
  );
  if (isConfigChange)
    return { type: "full-restart" };
  const isRunnerChange = some(
    changedFiles,
    (file) => file === wxt.config.runnerConfig.configFile
  );
  if (isRunnerChange)
    return { type: "browser-restart" };
  const changedSteps = new Set(
    changedFiles.flatMap(
      (changedFile) => findEffectedSteps(changedFile, currentOutput)
    )
  );
  if (changedSteps.size === 0)
    return { type: "no-change" };
  const unchangedOutput = {
    manifest: currentOutput.manifest,
    steps: [],
    publicAssets: []
  };
  const changedOutput = {
    manifest: currentOutput.manifest,
    steps: [],
    publicAssets: []
  };
  for (const step of currentOutput.steps) {
    if (changedSteps.has(step)) {
      changedOutput.steps.push(step);
    } else {
      unchangedOutput.steps.push(step);
    }
  }
  for (const asset of currentOutput.publicAssets) {
    if (changedSteps.has(asset)) {
      changedOutput.publicAssets.push(asset);
    } else {
      unchangedOutput.publicAssets.push(asset);
    }
  }
  const isOnlyHtmlChanges = changedFiles.length > 0 && every(changedFiles, (file) => file.endsWith(".html"));
  if (isOnlyHtmlChanges) {
    return {
      type: "html-reload",
      cachedOutput: unchangedOutput,
      rebuildGroups: changedOutput.steps.map((step) => step.entrypoints)
    };
  }
  const isOnlyContentScripts = changedOutput.steps.length > 0 && every(
    changedOutput.steps.flatMap((step) => step.entrypoints),
    (entry) => entry.type === "content-script"
  );
  if (isOnlyContentScripts) {
    return {
      type: "content-script-reload",
      cachedOutput: unchangedOutput,
      changedSteps: changedOutput.steps,
      rebuildGroups: changedOutput.steps.map((step) => step.entrypoints)
    };
  }
  return {
    type: "extension-reload",
    cachedOutput: unchangedOutput,
    rebuildGroups: changedOutput.steps.map((step) => step.entrypoints)
  };
}
function findEffectedSteps(changedFile, currentOutput) {
  const changes = [];
  const changedPath = normalizePath(changedFile);
  const isChunkEffected = (chunk) => (
    // If it's an HTML file with the same path, is is effected because HTML files need to be re-rendered
    // - fileName is normalized, relative bundle path, "<entrypoint-name>.html"
    chunk.type === "asset" && changedPath.replace("/index.html", ".html").endsWith(chunk.fileName) || // If it's a chunk that depends on the changed file, it is effected
    // - moduleIds are absolute, normalized paths
    chunk.type === "chunk" && chunk.moduleIds.includes(changedPath)
  );
  for (const step of currentOutput.steps) {
    const effectedChunk = step.chunks.find((chunk) => isChunkEffected(chunk));
    if (effectedChunk)
      changes.push(step);
  }
  const effectedAsset = currentOutput.publicAssets.find(
    (chunk) => isChunkEffected(chunk)
  );
  if (effectedAsset)
    changes.push(effectedAsset);
  return changes;
}

// src/core/utils/building/find-entrypoints.ts
import { relative as relative4, resolve as resolve8 } from "path";
import fs6 from "fs-extra";
import { minimatch } from "minimatch";
import { parseHTML as parseHTML2 } from "linkedom";
import JSON5 from "json5";
import glob2 from "fast-glob";
import pc2 from "picocolors";

// src/core/utils/building/import-entrypoint.ts
import createJITI from "jiti";
import { createUnimport as createUnimport2 } from "unimport";
import fs5 from "fs-extra";
import { relative as relative3, resolve as resolve7 } from "node:path";
import { transformSync } from "esbuild";
import { fileURLToPath } from "node:url";
async function importEntrypointFile(path8) {
  wxt.logger.debug("Loading file metadata:", path8);
  const normalPath = normalizePath(path8);
  const unimport2 = createUnimport2({
    ...wxt.config.imports,
    // Only allow specific imports, not all from the project
    dirs: []
  });
  await unimport2.init();
  const text = await fs5.readFile(path8, "utf-8");
  const textNoImports = removeProjectImportStatements(text);
  const { code } = await unimport2.injectImports(textNoImports);
  wxt.logger.debug(
    ["Text:", text, "No imports:", textNoImports, "Code:", code].join("\n")
  );
  const jiti = createJITI(
    typeof __filename !== "undefined" ? __filename : fileURLToPath(import.meta.url),
    {
      cache: false,
      debug: wxt.config.debug,
      esmResolve: true,
      alias: {
        "webextension-polyfill": resolve7(
          wxt.config.wxtModuleDir,
          "dist/virtual/mock-browser.js"
        )
      },
      // Continue using node to load TS files even if `bun run --bun` is detected. Jiti does not
      // respect the custom transform function when using it's native bun option.
      experimentalBun: false,
      // List of extensions to transform with esbuild
      extensions: [
        ".ts",
        ".cts",
        ".mts",
        ".tsx",
        ".js",
        ".cjs",
        ".mjs",
        ".jsx"
      ],
      transform(opts) {
        const isEntrypoint = opts.filename === normalPath;
        return transformSync(
          // Use modified source code for entrypoints
          isEntrypoint ? code : opts.source,
          getEsbuildOptions(opts)
        );
      }
    }
  );
  try {
    const res = await jiti(path8);
    return res.default;
  } catch (err) {
    const filePath = relative3(wxt.config.root, path8);
    if (err instanceof ReferenceError) {
      const variableName = err.message.replace(" is not defined", "");
      throw Error(
        `${filePath}: Cannot use imported variable "${variableName}" outside the main function. See https://wxt.dev/guide/entrypoints.html#side-effects`,
        { cause: err }
      );
    } else {
      wxt.logger.error(err);
      throw Error(`Failed to load entrypoint: ${filePath}`, { cause: err });
    }
  }
}
function getEsbuildOptions(opts) {
  const isJsx = opts.filename?.endsWith("x");
  return {
    format: "cjs",
    loader: isJsx ? "tsx" : "ts",
    ...isJsx ? {
      // `h` and `Fragment` are undefined, but that's OK because JSX is never evaluated while
      // grabbing the entrypoint's options.
      jsxFactory: "h",
      jsxFragment: "Fragment"
    } : void 0
  };
}

// src/core/utils/building/find-entrypoints.ts
async function findEntrypoints() {
  await fs6.mkdir(wxt.config.wxtDir, { recursive: true });
  await fs6.writeJson(resolve8(wxt.config.wxtDir, "tsconfig.json"), {});
  const relativePaths = await glob2(Object.keys(PATH_GLOB_TO_TYPE_MAP), {
    cwd: wxt.config.entrypointsDir
  });
  relativePaths.sort();
  const pathGlobs = Object.keys(PATH_GLOB_TO_TYPE_MAP);
  const entrypointInfos = relativePaths.reduce((results, relativePath) => {
    const inputPath = resolve8(wxt.config.entrypointsDir, relativePath);
    const name = getEntrypointName(wxt.config.entrypointsDir, inputPath);
    const matchingGlob = pathGlobs.find(
      (glob4) => minimatch(relativePath, glob4)
    );
    if (matchingGlob) {
      const type = PATH_GLOB_TO_TYPE_MAP[matchingGlob];
      results.push({
        name,
        inputPath,
        type,
        skipped: wxt.config.filterEntrypoints != null && !wxt.config.filterEntrypoints.has(name)
      });
    }
    return results;
  }, []);
  preventNoEntrypoints(entrypointInfos);
  preventDuplicateEntrypointNames(entrypointInfos);
  let hasBackground = false;
  const entrypoints = await Promise.all(
    entrypointInfos.map(async (info) => {
      const { type } = info;
      switch (type) {
        case "popup":
          return await getPopupEntrypoint(info);
        case "sidepanel":
          return await getSidepanelEntrypoint(info);
        case "options":
          return await getOptionsEntrypoint(info);
        case "background":
          hasBackground = true;
          return await getBackgroundEntrypoint(info);
        case "content-script":
          return await getContentScriptEntrypoint(info);
        case "unlisted-page":
          return await getUnlistedPageEntrypoint(info);
        case "unlisted-script":
          return await getUnlistedScriptEntrypoint(info);
        case "content-script-style":
          return {
            ...info,
            type,
            outputDir: resolve8(wxt.config.outDir, CONTENT_SCRIPT_OUT_DIR),
            options: {
              include: void 0,
              exclude: void 0
            }
          };
        default:
          return {
            ...info,
            type,
            outputDir: wxt.config.outDir,
            options: {
              include: void 0,
              exclude: void 0
            }
          };
      }
    })
  );
  if (wxt.config.command === "serve" && !hasBackground) {
    entrypoints.push(
      await getBackgroundEntrypoint({
        inputPath: VIRTUAL_NOOP_BACKGROUND_MODULE_ID,
        name: "background",
        type: "background",
        skipped: false
      })
    );
  }
  wxt.logger.debug("All entrypoints:", entrypoints);
  const skippedEntrypointNames = entrypointInfos.filter((item) => item.skipped).map((item) => item.name);
  if (skippedEntrypointNames.length) {
    wxt.logger.warn(
      `Filter excluded the following entrypoints:
${skippedEntrypointNames.map((item) => `${pc2.dim("-")} ${pc2.cyan(item)}`).join("\n")}`
    );
  }
  const targetEntrypoints = entrypoints.filter((entry) => {
    const { include, exclude } = entry.options;
    if (include?.length && exclude?.length) {
      wxt.logger.warn(
        `The ${entry.name} entrypoint lists both include and exclude, but only one can be used per entrypoint. Entrypoint ignored.`
      );
      return false;
    }
    if (exclude?.length && !include?.length) {
      return !exclude.includes(wxt.config.browser);
    }
    if (include?.length && !exclude?.length) {
      return include.includes(wxt.config.browser);
    }
    if (skippedEntrypointNames.includes(entry.name)) {
      return false;
    }
    return true;
  });
  wxt.logger.debug(`${wxt.config.browser} entrypoints:`, targetEntrypoints);
  await wxt.hooks.callHook("entrypoints:resolved", wxt, targetEntrypoints);
  return targetEntrypoints;
}
function preventDuplicateEntrypointNames(files) {
  const namesToPaths = files.reduce(
    (map, { name, inputPath }) => {
      map[name] ??= [];
      map[name].push(inputPath);
      return map;
    },
    {}
  );
  const errorLines = Object.entries(namesToPaths).reduce(
    (lines, [name, absolutePaths]) => {
      if (absolutePaths.length > 1) {
        lines.push(`- ${name}`);
        absolutePaths.forEach((absolutePath) => {
          lines.push(`  - ${relative4(wxt.config.root, absolutePath)}`);
        });
      }
      return lines;
    },
    []
  );
  if (errorLines.length > 0) {
    const errorContent = errorLines.join("\n");
    throw Error(
      `Multiple entrypoints with the same name detected, only one entrypoint for each name is allowed.

${errorContent}`
    );
  }
}
function preventNoEntrypoints(files) {
  if (files.length === 0) {
    throw Error(`No entrypoints found in ${wxt.config.entrypointsDir}`);
  }
}
async function getPopupEntrypoint(info) {
  const options = await getHtmlEntrypointOptions(
    info,
    {
      browserStyle: "browse_style",
      exclude: "exclude",
      include: "include",
      defaultIcon: "default_icon",
      defaultTitle: "default_title",
      mv2Key: "type"
    },
    {
      defaultTitle: (document) => document.querySelector("title")?.textContent || void 0
    },
    {
      defaultTitle: (content) => content,
      mv2Key: (content) => content === "page_action" ? "page_action" : "browser_action"
    }
  );
  return {
    type: "popup",
    name: "popup",
    options: resolvePerBrowserOptions(options, wxt.config.browser),
    inputPath: info.inputPath,
    outputDir: wxt.config.outDir,
    skipped: info.skipped
  };
}
async function getOptionsEntrypoint(info) {
  const options = await getHtmlEntrypointOptions(
    info,
    {
      browserStyle: "browse_style",
      chromeStyle: "chrome_style",
      exclude: "exclude",
      include: "include",
      openInTab: "open_in_tab"
    }
  );
  return {
    type: "options",
    name: "options",
    options: resolvePerBrowserOptions(options, wxt.config.browser),
    inputPath: info.inputPath,
    outputDir: wxt.config.outDir,
    skipped: info.skipped
  };
}
async function getUnlistedPageEntrypoint(info) {
  const options = await getHtmlEntrypointOptions(info, {
    exclude: "exclude",
    include: "include"
  });
  return {
    type: "unlisted-page",
    name: info.name,
    inputPath: info.inputPath,
    outputDir: wxt.config.outDir,
    options,
    skipped: info.skipped
  };
}
async function getUnlistedScriptEntrypoint({
  inputPath,
  name,
  skipped
}) {
  const defaultExport = await importEntrypoint(inputPath);
  if (defaultExport == null) {
    throw Error(
      `${name}: Default export not found, did you forget to call "export default defineUnlistedScript(...)"?`
    );
  }
  const { main: _, ...options } = defaultExport;
  return {
    type: "unlisted-script",
    name,
    inputPath,
    outputDir: wxt.config.outDir,
    options: resolvePerBrowserOptions(options, wxt.config.browser),
    skipped
  };
}
async function getBackgroundEntrypoint({
  inputPath,
  name,
  skipped
}) {
  let options = {};
  if (inputPath !== VIRTUAL_NOOP_BACKGROUND_MODULE_ID) {
    const defaultExport = await importEntrypoint(inputPath);
    if (defaultExport == null) {
      throw Error(
        `${name}: Default export not found, did you forget to call "export default defineBackground(...)"?`
      );
    }
    const { main: _, ...moduleOptions } = defaultExport;
    options = moduleOptions;
  }
  if (wxt.config.manifestVersion !== 3) {
    delete options.type;
  }
  return {
    type: "background",
    name,
    inputPath,
    outputDir: wxt.config.outDir,
    options: resolvePerBrowserOptions(options, wxt.config.browser),
    skipped
  };
}
async function getContentScriptEntrypoint({
  inputPath,
  name,
  skipped
}) {
  const { main: _, ...options } = await importEntrypoint(inputPath);
  if (options == null) {
    throw Error(
      `${name}: Default export not found, did you forget to call "export default defineContentScript(...)"?`
    );
  }
  return {
    type: "content-script",
    name,
    inputPath,
    outputDir: resolve8(wxt.config.outDir, CONTENT_SCRIPT_OUT_DIR),
    options: resolvePerBrowserOptions(options, wxt.config.browser),
    skipped
  };
}
async function getSidepanelEntrypoint(info) {
  const options = await getHtmlEntrypointOptions(
    info,
    {
      browserStyle: "browse_style",
      exclude: "exclude",
      include: "include",
      defaultIcon: "default_icon",
      defaultTitle: "default_title",
      openAtInstall: "open_at_install"
    },
    {
      defaultTitle: (document) => document.querySelector("title")?.textContent || void 0
    },
    {
      defaultTitle: (content) => content
    }
  );
  return {
    type: "sidepanel",
    name: info.name,
    options: resolvePerBrowserOptions(options, wxt.config.browser),
    inputPath: info.inputPath,
    outputDir: wxt.config.outDir,
    skipped: info.skipped
  };
}
async function getHtmlEntrypointOptions(info, keyMap, queries, parsers) {
  const content = await fs6.readFile(info.inputPath, "utf-8");
  const { document } = parseHTML2(content);
  const options = {};
  const defaultQuery = (manifestKey) => document.querySelector(`meta[name='manifest.${manifestKey}']`)?.getAttribute("content");
  Object.entries(keyMap).forEach(([_key, manifestKey]) => {
    const key = _key;
    const content2 = queries?.[key] ? queries[key](document, manifestKey) : defaultQuery(manifestKey);
    if (content2) {
      try {
        options[key] = (parsers?.[key] ?? JSON5.parse)(content2);
      } catch (err) {
        wxt.logger.fatal(
          `Failed to parse meta tag content. Usually this means you have invalid JSON5 content (content=${content2})`,
          err
        );
      }
    }
  });
  return options;
}
var PATH_GLOB_TO_TYPE_MAP = {
  "sandbox.html": "sandbox",
  "sandbox/index.html": "sandbox",
  "*.sandbox.html": "sandbox",
  "*.sandbox/index.html": "sandbox",
  "bookmarks.html": "bookmarks",
  "bookmarks/index.html": "bookmarks",
  "history.html": "history",
  "history/index.html": "history",
  "newtab.html": "newtab",
  "newtab/index.html": "newtab",
  "sidepanel.html": "sidepanel",
  "sidepanel/index.html": "sidepanel",
  "*.sidepanel.html": "sidepanel",
  "*.sidepanel/index.html": "sidepanel",
  "devtools.html": "devtools",
  "devtools/index.html": "devtools",
  "background.[jt]s": "background",
  "background/index.[jt]s": "background",
  [VIRTUAL_NOOP_BACKGROUND_MODULE_ID]: "background",
  "content.[jt]s?(x)": "content-script",
  "content/index.[jt]s?(x)": "content-script",
  "*.content.[jt]s?(x)": "content-script",
  "*.content/index.[jt]s?(x)": "content-script",
  [`content.${CSS_EXTENSIONS_PATTERN}`]: "content-script-style",
  [`*.content.${CSS_EXTENSIONS_PATTERN}`]: "content-script-style",
  [`content/index.${CSS_EXTENSIONS_PATTERN}`]: "content-script-style",
  [`*.content/index.${CSS_EXTENSIONS_PATTERN}`]: "content-script-style",
  "popup.html": "popup",
  "popup/index.html": "popup",
  "options.html": "options",
  "options/index.html": "options",
  "*.html": "unlisted-page",
  "*/index.html": "unlisted-page",
  "*.[jt]s?(x)": "unlisted-script",
  "*/index.[jt]s?(x)": "unlisted-script",
  [`*.${CSS_EXTENSIONS_PATTERN}`]: "unlisted-style",
  [`*/index.${CSS_EXTENSIONS_PATTERN}`]: "unlisted-style"
};
var CONTENT_SCRIPT_OUT_DIR = "content-scripts";
function importEntrypoint(path8) {
  return wxt.config.experimental.viteRuntime ? wxt.builder.importEntrypoint(path8) : importEntrypointFile(path8);
}

// src/core/utils/building/generate-wxt-dir.ts
import { createUnimport as createUnimport3 } from "unimport";
import fs7 from "fs-extra";
import { relative as relative5, resolve as resolve9 } from "path";
import path4 from "node:path";

// src/core/utils/i18n.ts
var predefinedMessages = {
  "@@extension_id": {
    message: "<browser.runtime.id>",
    description: "The extension or app ID; you might use this string to construct URLs for resources inside the extension. Even unlocalized extensions can use this message.\nNote: You can't use this message in a manifest file."
  },
  "@@ui_locale": {
    message: "<browser.i18n.getUiLocale()>",
    description: ""
  },
  "@@bidi_dir": {
    message: "<ltr|rtl>",
    description: 'The text direction for the current locale, either "ltr" for left-to-right languages such as English or "rtl" for right-to-left languages such as Japanese.'
  },
  "@@bidi_reversed_dir": {
    message: "<rtl|ltr>",
    description: `If the @@bidi_dir is "ltr", then this is "rtl"; otherwise, it's "ltr".`
  },
  "@@bidi_start_edge": {
    message: "<left|right>",
    description: `If the @@bidi_dir is "ltr", then this is "left"; otherwise, it's "right".`
  },
  "@@bidi_end_edge": {
    message: "<right|left>",
    description: `If the @@bidi_dir is "ltr", then this is "right"; otherwise, it's "left".`
  }
};
function parseI18nMessages(messagesJson) {
  return Object.entries({
    ...predefinedMessages,
    ...messagesJson
  }).map(([name, details]) => ({
    name,
    ...details
  }));
}

// src/core/utils/building/generate-wxt-dir.ts
async function generateTypesDir(entrypoints) {
  await fs7.ensureDir(wxt.config.typesDir);
  const references = [];
  if (wxt.config.imports !== false) {
    const unimport2 = createUnimport3(wxt.config.imports);
    references.push(await writeImportsDeclarationFile(unimport2));
    if (wxt.config.imports.eslintrc.enabled) {
      await writeImportsEslintFile(unimport2, wxt.config.imports);
    }
  }
  references.push(await writePathsDeclarationFile(entrypoints));
  references.push(await writeI18nDeclarationFile());
  references.push(await writeGlobalsDeclarationFile());
  const mainReference = await writeMainDeclarationFile(references);
  await writeTsConfigFile(mainReference);
}
async function writeImportsDeclarationFile(unimport2) {
  const filePath = resolve9(wxt.config.typesDir, "imports.d.ts");
  await unimport2.scanImportsFromDir(void 0, { cwd: wxt.config.srcDir });
  await writeFileIfDifferent(
    filePath,
    ["// Generated by wxt", await unimport2.generateTypeDeclarations()].join(
      "\n"
    ) + "\n"
  );
  return filePath;
}
async function writeImportsEslintFile(unimport2, options) {
  const globals2 = {};
  const eslintrc = { globals: globals2 };
  (await unimport2.getImports()).map((i) => i.as ?? i.name).filter(Boolean).sort().forEach((name) => {
    eslintrc.globals[name] = options.eslintrc.globalsPropValue;
  });
  await fs7.writeJson(options.eslintrc.filePath, eslintrc, { spaces: 2 });
}
async function writePathsDeclarationFile(entrypoints) {
  const filePath = resolve9(wxt.config.typesDir, "paths.d.ts");
  const unions = entrypoints.map(
    (entry) => getEntrypointBundlePath(
      entry,
      wxt.config.outDir,
      isHtmlEntrypoint(entry) ? ".html" : ".js"
    )
  ).concat(await getPublicFiles()).map(normalizePath).map((path8) => `    | "/${path8}"`).sort().join("\n");
  const template = `// Generated by wxt
import "wxt/browser";

declare module "wxt/browser" {
  export type PublicPath =
{{ union }}
  type HtmlPublicPath = Extract<PublicPath, \`\${string}.html\`>
  export interface WxtRuntime extends Runtime.Static {
    getURL(path: PublicPath): string;
    getURL(path: \`\${HtmlPublicPath}\${string}\`): string;
  }
}
`;
  await writeFileIfDifferent(
    filePath,
    template.replace("{{ union }}", unions || "    | never")
  );
  return filePath;
}
async function writeI18nDeclarationFile() {
  const filePath = resolve9(wxt.config.typesDir, "i18n.d.ts");
  const defaultLocale = wxt.config.manifest.default_locale;
  const template = `// Generated by wxt
import "wxt/browser";

declare module "wxt/browser" {
  /**
   * See https://developer.chrome.com/docs/extensions/reference/i18n/#method-getMessage
   */
  interface GetMessageOptions {
    /**
     * See https://developer.chrome.com/docs/extensions/reference/i18n/#method-getMessage
     */
    escapeLt?: boolean
  }

  export interface WxtI18n extends I18n.Static {
{{ overrides }}
  }
}
`;
  let messages;
  if (defaultLocale) {
    const defaultLocalePath = path4.resolve(
      wxt.config.publicDir,
      "_locales",
      defaultLocale,
      "messages.json"
    );
    const content = JSON.parse(await fs7.readFile(defaultLocalePath, "utf-8"));
    messages = parseI18nMessages(content);
  } else {
    messages = parseI18nMessages({});
  }
  const overrides = messages.map((message) => {
    return `    /**
     * ${message.description || "No message description."}
     *
     * "${message.message}"
     */
    getMessage(
      messageName: "${message.name}",
      substitutions?: string | string[],
      options?: GetMessageOptions,
    ): string;`;
  });
  await writeFileIfDifferent(
    filePath,
    template.replace("{{ overrides }}", overrides.join("\n"))
  );
  return filePath;
}
async function writeGlobalsDeclarationFile() {
  const filePath = resolve9(wxt.config.typesDir, "globals.d.ts");
  const globals2 = [...getGlobals(wxt.config), ...getEntrypointGlobals("")];
  await writeFileIfDifferent(
    filePath,
    [
      "// Generated by wxt",
      "export {}",
      "interface ImportMetaEnv {",
      ...globals2.map((global) => `  readonly ${global.name}: ${global.type};`),
      "}",
      "interface ImportMeta {",
      "  readonly env: ImportMetaEnv",
      "}"
    ].join("\n") + "\n"
  );
  return filePath;
}
async function writeMainDeclarationFile(references) {
  const dir = wxt.config.wxtDir;
  const filePath = resolve9(dir, "wxt.d.ts");
  await writeFileIfDifferent(
    filePath,
    [
      "// Generated by wxt",
      `/// <reference types="wxt/vite-builder-env" />`,
      ...references.map(
        (ref) => `/// <reference types="./${normalizePath(relative5(dir, ref))}" />`
      )
    ].join("\n") + "\n"
  );
  return filePath;
}
async function writeTsConfigFile(mainReference) {
  const dir = wxt.config.wxtDir;
  const getTsconfigPath = (path8) => normalizePath(relative5(dir, path8));
  const paths = Object.entries(wxt.config.alias).flatMap(([alias, absolutePath]) => {
    const aliasPath = getTsconfigPath(absolutePath);
    return [
      `      "${alias}": ["${aliasPath}"]`,
      `      "${alias}/*": ["${aliasPath}/*"]`
    ];
  }).join(",\n");
  await writeFileIfDifferent(
    resolve9(dir, "tsconfig.json"),
    `{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "noEmit": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "strict": true,
    "skipLibCheck": true,
    "paths": {
${paths}
    }
  },
  "include": [
    "${getTsconfigPath(wxt.config.root)}/**/*",
    "./${getTsconfigPath(mainReference)}"
  ],
  "exclude": ["${getTsconfigPath(wxt.config.outBaseDir)}"]
}`
  );
}

// src/core/utils/building/resolve-config.ts
import { loadConfig } from "c12";
import path5 from "node:path";

// src/core/utils/cache.ts
import fs8, { ensureDir as ensureDir2 } from "fs-extra";
import { dirname as dirname4, resolve as resolve10 } from "path";
function createFsCache(wxtDir) {
  const getPath = (key) => resolve10(wxtDir, "cache", encodeURIComponent(key));
  return {
    async set(key, value) {
      const path8 = getPath(key);
      await ensureDir2(dirname4(path8));
      await writeFileIfDifferent(path8, value);
    },
    async get(key) {
      const path8 = getPath(key);
      try {
        return await fs8.readFile(path8, "utf-8");
      } catch {
        return void 0;
      }
    }
  };
}

// src/core/utils/building/resolve-config.ts
import defu from "defu";

// src/core/utils/package.ts
import { resolve as resolve11 } from "node:path";
import fs9 from "fs-extra";
async function getPackageJson() {
  const file = resolve11(wxt.config.root, "package.json");
  try {
    return await fs9.readJson(file);
  } catch (err) {
    wxt.logger.debug(
      `Failed to read package.json at: ${file}. Returning undefined.`
    );
    return {};
  }
}
function isModuleInstalled(name) {
  return import(
    /* @vite-ignore */
    name
  ).then(() => true).catch(() => false);
}

// src/core/utils/building/resolve-config.ts
import fs10 from "fs-extra";
async function resolveConfig(inlineConfig, command) {
  let userConfig = {};
  let userConfigMetadata;
  if (inlineConfig.configFile !== false) {
    const { config: loadedConfig, ...metadata } = await loadConfig({
      configFile: inlineConfig.configFile,
      name: "wxt",
      cwd: inlineConfig.root ?? process.cwd(),
      rcFile: false,
      jitiOptions: {
        esmResolve: true
      }
    });
    userConfig = loadedConfig ?? {};
    userConfigMetadata = metadata;
  }
  const mergedConfig = await mergeInlineConfig(inlineConfig, userConfig);
  const debug = mergedConfig.debug ?? false;
  const logger = mergedConfig.logger ?? consola;
  if (debug)
    logger.level = LogLevels.debug;
  const browser = mergedConfig.browser ?? "chrome";
  const manifestVersion = mergedConfig.manifestVersion ?? (browser === "firefox" || browser === "safari" ? 2 : 3);
  const mode = mergedConfig.mode ?? COMMAND_MODES[command];
  const env = { browser, command, manifestVersion, mode };
  const root = path5.resolve(
    inlineConfig.root ?? userConfig.root ?? process.cwd()
  );
  const wxtDir = path5.resolve(root, ".wxt");
  const wxtModuleDir = await resolveWxtModuleDir();
  const srcDir = path5.resolve(root, mergedConfig.srcDir ?? root);
  const entrypointsDir = path5.resolve(
    srcDir,
    mergedConfig.entrypointsDir ?? "entrypoints"
  );
  if (await isDirMissing(entrypointsDir)) {
    logMissingDir(logger, "Entrypoints", entrypointsDir);
  }
  const filterEntrypoints = !!mergedConfig.filterEntrypoints?.length ? new Set(mergedConfig.filterEntrypoints) : void 0;
  const publicDir = path5.resolve(srcDir, mergedConfig.publicDir ?? "public");
  if (await isDirMissing(publicDir)) {
    logMissingDir(logger, "Public", publicDir);
  }
  const typesDir = path5.resolve(wxtDir, "types");
  const outBaseDir = path5.resolve(root, mergedConfig.outDir ?? ".output");
  const outDir = path5.resolve(outBaseDir, `${browser}-mv${manifestVersion}`);
  const reloadCommand = mergedConfig.dev?.reloadCommand ?? "Alt+R";
  const runnerConfig = await loadConfig({
    name: "web-ext",
    cwd: root,
    globalRc: true,
    rcFile: ".webextrc",
    overrides: inlineConfig.runner,
    defaults: userConfig.runner
  });
  const alias = Object.fromEntries(
    Object.entries({
      ...mergedConfig.alias,
      "@": srcDir,
      "~": srcDir,
      "@@": root,
      "~~": root
    }).map(([key, value]) => [key, path5.resolve(root, value)])
  );
  let devServerConfig;
  if (command === "serve") {
    let port = mergedConfig.dev?.server?.port;
    if (port == null || !isFinite(port)) {
      const { default: getPort, portNumbers } = await import("get-port");
      port = await getPort({ port: portNumbers(3e3, 3010) });
    }
    devServerConfig = {
      port,
      hostname: "localhost"
    };
  }
  return {
    browser,
    command,
    debug,
    entrypointsDir,
    filterEntrypoints,
    env,
    fsCache: createFsCache(wxtDir),
    imports: await getUnimportOptions(wxtDir, logger, mergedConfig),
    logger,
    manifest: await resolveManifestConfig(env, mergedConfig.manifest),
    manifestVersion,
    mode,
    outBaseDir,
    outDir,
    publicDir,
    wxtModuleDir,
    root,
    runnerConfig,
    srcDir,
    typesDir,
    wxtDir,
    zip: resolveZipConfig(root, mergedConfig),
    transformManifest: mergedConfig.transformManifest,
    analysis: resolveAnalysisConfig(root, mergedConfig),
    userConfigMetadata: userConfigMetadata ?? {},
    alias,
    experimental: defu(mergedConfig.experimental, {
      includeBrowserPolyfill: true,
      viteRuntime: false
    }),
    dev: {
      server: devServerConfig,
      reloadCommand
    },
    hooks: mergedConfig.hooks ?? {},
    vite: mergedConfig.vite ?? (() => ({}))
  };
}
async function resolveManifestConfig(env, manifest) {
  return await (typeof manifest === "function" ? manifest(env) : manifest ?? {});
}
async function mergeInlineConfig(inlineConfig, userConfig) {
  const imports = inlineConfig.imports === false || userConfig.imports === false ? false : userConfig.imports == null && inlineConfig.imports == null ? void 0 : defu(inlineConfig.imports ?? {}, userConfig.imports ?? {});
  const manifest = async (env) => {
    const user = await resolveManifestConfig(env, userConfig.manifest);
    const inline = await resolveManifestConfig(env, inlineConfig.manifest);
    return defu(inline, user);
  };
  const transformManifest = (manifest2) => {
    userConfig.transformManifest?.(manifest2);
    inlineConfig.transformManifest?.(manifest2);
  };
  const builderConfig = await mergeBuilderConfig(inlineConfig, userConfig);
  return {
    ...defu(inlineConfig, userConfig),
    // Custom merge values
    transformManifest,
    imports,
    manifest,
    ...builderConfig
  };
}
function resolveZipConfig(root, mergedConfig) {
  const downloadedPackagesDir = path5.resolve(root, ".wxt/local_modules");
  return {
    name: void 0,
    sourcesTemplate: "{{name}}-{{version}}-sources.zip",
    artifactTemplate: "{{name}}-{{version}}-{{browser}}.zip",
    sourcesRoot: root,
    includeSources: [],
    compressionLevel: 9,
    ...mergedConfig.zip,
    excludeSources: [
      "**/node_modules",
      // WXT files
      "**/web-ext.config.ts",
      // Hidden files
      "**/.*",
      // Tests
      "**/__tests__/**",
      "**/*.+(test|spec).?(c|m)+(j|t)s?(x)",
      // From user
      ...mergedConfig.zip?.excludeSources ?? []
    ],
    downloadPackages: mergedConfig.zip?.downloadPackages ?? [],
    downloadedPackagesDir
  };
}
function resolveAnalysisConfig(root, mergedConfig) {
  const analysisOutputFile = path5.resolve(
    root,
    mergedConfig.analysis?.outputFile ?? "stats.html"
  );
  const analysisOutputDir = path5.dirname(analysisOutputFile);
  const analysisOutputName = path5.parse(analysisOutputFile).name;
  return {
    enabled: mergedConfig.analysis?.enabled ?? false,
    open: mergedConfig.analysis?.open ?? false,
    template: mergedConfig.analysis?.template ?? "treemap",
    outputFile: analysisOutputFile,
    outputDir: analysisOutputDir,
    outputName: analysisOutputName,
    keepArtifacts: mergedConfig.analysis?.keepArtifacts ?? false
  };
}
async function getUnimportOptions(wxtDir, logger, config) {
  if (config.imports === false)
    return false;
  const enabledConfig = config.imports?.eslintrc?.enabled;
  let enabled;
  switch (enabledConfig) {
    case void 0:
    case "auto":
      enabled = await isModuleInstalled("eslint");
      break;
    default:
      enabled = enabledConfig;
  }
  const defaultOptions = {
    debugLog: logger.debug,
    imports: [
      { name: "defineConfig", from: "wxt" },
      { name: "fakeBrowser", from: "wxt/testing" }
    ],
    presets: [
      { package: "wxt/client" },
      { package: "wxt/browser" },
      { package: "wxt/sandbox" },
      { package: "wxt/storage" }
    ],
    warn: logger.warn,
    dirs: ["components", "composables", "hooks", "utils"],
    eslintrc: {
      enabled,
      filePath: path5.resolve(wxtDir, "eslintrc-auto-import.json"),
      globalsPropValue: true
    }
  };
  return defu(
    config.imports ?? {},
    defaultOptions
  );
}
async function resolveWxtModuleDir() {
  const requireResolve = __require?.resolve ?? (await import("node:module")).default.createRequire(import.meta.url).resolve;
  return path5.resolve(requireResolve("wxt"), "../..");
}
async function isDirMissing(dir) {
  return !await fs10.exists(dir);
}
function logMissingDir(logger, name, expected) {
  logger.warn(
    `${name} directory not found: ./${normalizePath(
      path5.relative(process.cwd(), expected)
    )}`
  );
}
var COMMAND_MODES = {
  build: "production",
  serve: "development"
};
async function mergeBuilderConfig(inlineConfig, userConfig) {
  const vite = await import("vite").catch(() => void 0);
  if (vite) {
    return {
      vite: async (env) => {
        const resolvedInlineConfig = await inlineConfig.vite?.(env) ?? {};
        const resolvedUserConfig = await userConfig.vite?.(env) ?? {};
        return vite.mergeConfig(resolvedUserConfig, resolvedInlineConfig);
      }
    };
  }
  throw Error("Builder not found. Make sure vite is installed.");
}

// src/core/utils/building/group-entrypoints.ts
function groupEntrypoints(entrypoints) {
  const groupIndexMap = {};
  const groups = [];
  for (const entry of entrypoints) {
    let group = ENTRY_TYPE_TO_GROUP_MAP[entry.type];
    if (entry.type === "background" && entry.options.type === "module") {
      group = "esm";
    }
    if (group === "individual") {
      groups.push(entry);
    } else {
      let groupIndex = groupIndexMap[group];
      if (groupIndex == null) {
        groupIndex = groups.push([]) - 1;
        groupIndexMap[group] = groupIndex;
      }
      groups[groupIndex].push(entry);
    }
  }
  return groups;
}
var ENTRY_TYPE_TO_GROUP_MAP = {
  sandbox: "sandboxed-esm",
  popup: "esm",
  newtab: "esm",
  history: "esm",
  options: "esm",
  devtools: "esm",
  bookmarks: "esm",
  sidepanel: "esm",
  "unlisted-page": "esm",
  background: "individual",
  "content-script": "individual",
  "unlisted-script": "individual",
  "unlisted-style": "individual",
  "content-script-style": "individual"
};

// src/core/utils/building/internal-build.ts
import pc5 from "picocolors";
import fs13 from "fs-extra";

// src/core/utils/log/printBuildSummary.ts
import { resolve as resolve12 } from "path";

// src/core/utils/log/printFileList.ts
import path6 from "node:path";
import pc3 from "picocolors";
import fs11 from "fs-extra";
import { filesize } from "filesize";

// src/core/utils/log/printTable.ts
function printTable(log, header, rows, gap = 2) {
  if (rows.length === 0)
    return;
  const columnWidths = rows.reduce(
    (widths, row) => {
      for (let i = 0; i < Math.max(widths.length, row.length); i++) {
        widths[i] = Math.max(row[i]?.length ?? 0, widths[i] ?? 0);
      }
      return widths;
    },
    rows[0].map((column) => column.length)
  );
  let str = "";
  rows.forEach((row, i) => {
    row.forEach((col, j) => {
      str += col.padEnd(columnWidths[j], " ");
      if (j !== row.length - 1)
        str += "".padEnd(gap, " ");
    });
    if (i !== rows.length - 1)
      str += "\n";
  });
  log(`${header}
${str}`);
}

// src/core/utils/log/printFileList.ts
async function printFileList(log, header, baseDir, files) {
  let totalSize = 0;
  const fileRows = await Promise.all(
    files.map(async (file, i) => {
      const parts = [
        path6.relative(process.cwd(), baseDir) + path6.sep,
        path6.relative(baseDir, file)
      ];
      const prefix = i === files.length - 1 ? "  \u2514\u2500" : "  \u251C\u2500";
      const color = getChunkColor(file);
      const stats = await fs11.lstat(file);
      totalSize += stats.size;
      const size = String(filesize(stats.size));
      return [
        `${pc3.gray(prefix)} ${pc3.dim(parts[0])}${color(parts[1])}`,
        pc3.dim(size)
      ];
    })
  );
  fileRows.push([`${pc3.cyan("\u03A3 Total size:")} ${String(filesize(totalSize))}`]);
  printTable(log, header, fileRows);
}
var DEFAULT_COLOR = pc3.blue;
var CHUNK_COLORS = {
  ".js.map": pc3.gray,
  ".cjs.map": pc3.gray,
  ".mjs.map": pc3.gray,
  ".html": pc3.green,
  ".css": pc3.magenta,
  ".js": pc3.cyan,
  ".cjs": pc3.cyan,
  ".mjs": pc3.cyan,
  ".zip": pc3.yellow
};
function getChunkColor(filename) {
  return Object.entries(CHUNK_COLORS).find(([key]) => filename.endsWith(key))?.[1] ?? DEFAULT_COLOR;
}

// src/core/utils/log/printBuildSummary.ts
async function printBuildSummary(log, header, output) {
  const chunks = [
    ...output.steps.flatMap((step) => step.chunks),
    ...output.publicAssets
  ].sort((l, r) => {
    const lWeight = getChunkSortWeight(l.fileName);
    const rWeight = getChunkSortWeight(r.fileName);
    const diff = lWeight - rWeight;
    if (diff !== 0)
      return diff;
    return l.fileName.localeCompare(r.fileName);
  });
  const files = chunks.map(
    (chunk) => resolve12(wxt.config.outDir, chunk.fileName)
  );
  await printFileList(log, header, wxt.config.outDir, files);
}
var DEFAULT_SORT_WEIGHT = 100;
var CHUNK_SORT_WEIGHTS = {
  "manifest.json": 0,
  ".html": 1,
  ".js.map": 2,
  ".js": 2,
  ".css": 3
};
function getChunkSortWeight(filename) {
  return Object.entries(CHUNK_SORT_WEIGHTS).find(
    ([key]) => filename.endsWith(key)
  )?.[1] ?? DEFAULT_SORT_WEIGHT;
}

// src/core/utils/log/printHeader.ts
import pc4 from "picocolors";

// src/core/utils/building/internal-build.ts
import glob3 from "fast-glob";

// src/core/utils/manifest.ts
import fs12 from "fs-extra";
import { resolve as resolve13 } from "path";

// src/core/utils/content-security-policy.ts
var ContentSecurityPolicy = class _ContentSecurityPolicy {
  static DIRECTIVE_ORDER = {
    "default-src": 0,
    "script-src": 1,
    "object-src": 2
  };
  data;
  constructor(csp) {
    if (csp) {
      const sections = csp.split(";").map((section) => section.trim());
      this.data = sections.reduce((data, section) => {
        const [key, ...values] = section.split(" ").map((item) => item.trim());
        if (key)
          data[key] = values;
        return data;
      }, {});
    } else {
      this.data = {};
    }
  }
  /**
   * Ensure a set of values are listed under a directive.
   */
  add(directive, ...newValues) {
    const values = this.data[directive] ?? [];
    newValues.forEach((newValue) => {
      if (!values.includes(newValue))
        values.push(newValue);
    });
    this.data[directive] = values;
    return this;
  }
  toString() {
    const directives = Object.entries(this.data).sort(([l], [r]) => {
      const lo = _ContentSecurityPolicy.DIRECTIVE_ORDER[l] ?? 2;
      const ro = _ContentSecurityPolicy.DIRECTIVE_ORDER[r] ?? 2;
      return lo - ro;
    });
    return directives.map((entry) => entry.flat().join(" ")).join("; ") + ";";
  }
};

// src/core/utils/content-scripts.ts
function hashContentScriptOptions(options) {
  const simplifiedOptions = mapWxtOptionsToContentScript(
    options,
    void 0,
    void 0
  );
  Object.keys(simplifiedOptions).forEach((key) => {
    if (simplifiedOptions[key] == null)
      delete simplifiedOptions[key];
  });
  const withDefaults = {
    exclude_globs: [],
    exclude_matches: [],
    include_globs: [],
    match_about_blank: false,
    run_at: "document_idle",
    all_frames: false,
    // @ts-expect-error - not in type
    match_origin_as_fallback: false,
    world: "ISOLATED",
    ...simplifiedOptions
  };
  return JSON.stringify(
    Object.entries(withDefaults).map(([key, value]) => {
      if (Array.isArray(value))
        return [key, value.sort()];
      else
        return [key, value];
    }).sort((l, r) => l[0].localeCompare(r[0]))
  );
}
function mapWxtOptionsToContentScript(options, js, css) {
  return {
    matches: options.matches,
    all_frames: options.allFrames,
    match_about_blank: options.matchAboutBlank,
    exclude_globs: options.excludeGlobs,
    exclude_matches: options.excludeMatches,
    include_globs: options.includeGlobs,
    run_at: options.runAt,
    css,
    js,
    // @ts-expect-error: untyped chrome options
    match_origin_as_fallback: options.matchOriginAsFallback,
    world: options.world
  };
}
function mapWxtOptionsToRegisteredContentScript(options, js, css) {
  return {
    allFrames: options.allFrames,
    excludeMatches: options.excludeMatches,
    matches: options.matches,
    runAt: options.runAt,
    js,
    css,
    // @ts-expect-error: Chrome accepts this, not typed in webextension-polyfill (https://developer.chrome.com/docs/extensions/reference/scripting/#type-RegisteredContentScript)
    world: options.world
  };
}
function getContentScriptJs(config, entrypoint) {
  return [getEntrypointBundlePath(entrypoint, config.outDir, ".js")];
}

// src/core/utils/manifest.ts
import defu2 from "defu";
async function writeManifest(manifest, output) {
  const str = wxt.config.mode === "production" ? JSON.stringify(manifest) : JSON.stringify(manifest, null, 2);
  await fs12.ensureDir(wxt.config.outDir);
  await writeFileIfDifferent(resolve13(wxt.config.outDir, "manifest.json"), str);
  output.publicAssets.unshift({
    type: "asset",
    fileName: "manifest.json"
  });
}
async function generateManifest(entrypoints, buildOutput) {
  const warnings = [];
  const pkg = await getPackageJson();
  let versionName = wxt.config.manifest.version_name ?? wxt.config.manifest.version ?? pkg?.version;
  if (versionName == null) {
    versionName = "0.0.0";
    wxt.logger.warn(
      'Extension version not found, defaulting to "0.0.0". Add a version to your `package.json` or `wxt.config.ts` file. For more details, see: https://wxt.dev/guide/manifest.html#version-and-version-name'
    );
  }
  const version2 = wxt.config.manifest.version ?? simplifyVersion(versionName);
  const baseManifest = {
    manifest_version: wxt.config.manifestVersion,
    name: pkg?.name,
    description: pkg?.description,
    version: version2,
    short_name: pkg?.shortName,
    icons: discoverIcons(buildOutput)
  };
  const userManifest = wxt.config.manifest;
  let manifest = defu2(
    userManifest,
    baseManifest
  );
  if (wxt.config.command === "serve" && wxt.config.dev.reloadCommand) {
    if (manifest.commands && Object.keys(manifest.commands).length >= 4) {
      warnings.push([
        "Extension already has 4 registered commands, WXT's reload command is disabled"
      ]);
    } else {
      manifest.commands ??= {};
      manifest.commands["wxt:reload-extension"] = {
        description: "Reload the extension during development",
        suggested_key: {
          default: wxt.config.dev.reloadCommand
        }
      };
    }
  }
  manifest.version = version2;
  manifest.version_name = // Firefox doesn't support version_name
  wxt.config.browser === "firefox" || versionName === version2 ? void 0 : versionName;
  addEntrypoints(manifest, entrypoints, buildOutput);
  if (wxt.config.command === "serve")
    addDevModeCsp(manifest);
  if (wxt.config.command === "serve")
    addDevModePermissions(manifest);
  wxt.config.transformManifest?.(manifest);
  await wxt.hooks.callHook("build:manifestGenerated", wxt, manifest);
  if (wxt.config.manifestVersion === 2) {
    convertWebAccessibleResourcesToMv2(manifest);
    convertActionToMv2(manifest);
    moveHostPermissionsToPermissions(manifest);
  }
  if (wxt.config.manifestVersion === 3) {
    validateMv3WebAccessbileResources(manifest);
  }
  stripKeys(manifest);
  if (manifest.name == null)
    throw Error(
      "Manifest 'name' is missing. Either:\n1. Set the name in your <rootDir>/package.json\n2. Set a name via the manifest option in your wxt.config.ts"
    );
  if (manifest.version == null) {
    throw Error(
      "Manifest 'version' is missing. Either:\n1. Add a version in your <rootDir>/package.json\n2. Pass the version via the manifest option in your wxt.config.ts"
    );
  }
  return {
    manifest,
    warnings
  };
}
function simplifyVersion(versionName) {
  const version2 = /^((0|[1-9][0-9]{0,8})([.](0|[1-9][0-9]{0,8})){0,3}).*$/.exec(
    versionName
  )?.[1];
  if (version2 == null)
    throw Error(
      `Cannot simplify package.json version "${versionName}" to a valid extension version, "X.Y.Z"`
    );
  return version2;
}
function addEntrypoints(manifest, entrypoints, buildOutput) {
  const entriesByType = entrypoints.reduce((map, entrypoint) => {
    map[entrypoint.type] ??= [];
    map[entrypoint.type]?.push(entrypoint);
    return map;
  }, {});
  const background = entriesByType["background"]?.[0];
  const bookmarks = entriesByType["bookmarks"]?.[0];
  const contentScripts = entriesByType["content-script"];
  const devtools = entriesByType["devtools"]?.[0];
  const history = entriesByType["history"]?.[0];
  const newtab = entriesByType["newtab"]?.[0];
  const options = entriesByType["options"]?.[0];
  const popup = entriesByType["popup"]?.[0];
  const sandboxes = entriesByType["sandbox"];
  const sidepanels = entriesByType["sidepanel"];
  if (background) {
    const script = getEntrypointBundlePath(
      background,
      wxt.config.outDir,
      ".js"
    );
    if (wxt.config.browser === "firefox" && wxt.config.manifestVersion === 3) {
      manifest.background = {
        type: background.options.type,
        scripts: [script]
      };
    } else if (wxt.config.manifestVersion === 3) {
      manifest.background = {
        type: background.options.type,
        service_worker: script
      };
    } else {
      manifest.background = {
        persistent: background.options.persistent,
        scripts: [script]
      };
    }
  }
  if (bookmarks) {
    if (wxt.config.browser === "firefox") {
      wxt.logger.warn(
        "Bookmarks are not supported by Firefox. chrome_url_overrides.bookmarks was not added to the manifest"
      );
    } else {
      manifest.chrome_url_overrides ??= {};
      manifest.chrome_url_overrides.bookmarks = getEntrypointBundlePath(
        bookmarks,
        wxt.config.outDir,
        ".html"
      );
    }
  }
  if (history) {
    if (wxt.config.browser === "firefox") {
      wxt.logger.warn(
        "Bookmarks are not supported by Firefox. chrome_url_overrides.history was not added to the manifest"
      );
    } else {
      manifest.chrome_url_overrides ??= {};
      manifest.chrome_url_overrides.history = getEntrypointBundlePath(
        history,
        wxt.config.outDir,
        ".html"
      );
    }
  }
  if (newtab) {
    manifest.chrome_url_overrides ??= {};
    manifest.chrome_url_overrides.newtab = getEntrypointBundlePath(
      newtab,
      wxt.config.outDir,
      ".html"
    );
  }
  if (popup) {
    const default_popup = getEntrypointBundlePath(
      popup,
      wxt.config.outDir,
      ".html"
    );
    const options2 = {};
    if (popup.options.defaultIcon)
      options2.default_icon = popup.options.defaultIcon;
    if (popup.options.defaultTitle)
      options2.default_title = popup.options.defaultTitle;
    if (popup.options.browserStyle)
      options2.browser_style = popup.options.browserStyle;
    if (manifest.manifest_version === 3) {
      manifest.action = {
        ...manifest.action ?? {},
        ...options2,
        default_popup
      };
    } else {
      const key = popup.options.mv2Key ?? "browser_action";
      manifest[key] = {
        ...manifest[key] ?? {},
        ...options2,
        default_popup
      };
    }
  }
  if (devtools) {
    manifest.devtools_page = getEntrypointBundlePath(
      devtools,
      wxt.config.outDir,
      ".html"
    );
  }
  if (options) {
    const page = getEntrypointBundlePath(options, wxt.config.outDir, ".html");
    manifest.options_ui = {
      open_in_tab: options.options.openInTab,
      browser_style: wxt.config.browser === "firefox" ? options.options.browserStyle : void 0,
      chrome_style: wxt.config.browser !== "firefox" ? options.options.chromeStyle : void 0,
      page
    };
  }
  if (sandboxes?.length) {
    if (wxt.config.browser === "firefox") {
      wxt.logger.warn(
        "Sandboxed pages not supported by Firefox. sandbox.pages was not added to the manifest"
      );
    } else {
      manifest.sandbox = {
        pages: sandboxes.map(
          (entry) => getEntrypointBundlePath(entry, wxt.config.outDir, ".html")
        )
      };
    }
  }
  if (sidepanels?.length) {
    const defaultSidepanel = sidepanels.find((entry) => entry.name === "sidepanel") ?? sidepanels[0];
    const page = getEntrypointBundlePath(
      defaultSidepanel,
      wxt.config.outDir,
      ".html"
    );
    if (wxt.config.browser === "firefox") {
      manifest.sidebar_action = {
        default_panel: page,
        browser_style: defaultSidepanel.options.browserStyle,
        default_icon: defaultSidepanel.options.defaultIcon,
        default_title: defaultSidepanel.options.defaultTitle,
        open_at_install: defaultSidepanel.options.openAtInstall
      };
    } else if (wxt.config.manifestVersion === 3) {
      manifest.side_panel = {
        default_path: page
      };
      addPermission(manifest, "sidePanel");
    } else {
      wxt.logger.warn(
        "Side panel not supported by Chromium using MV2. side_panel.default_path was not added to the manifest"
      );
    }
  }
  if (contentScripts?.length) {
    const cssMap = getContentScriptsCssMap(buildOutput, contentScripts);
    if (wxt.config.command === "serve" && wxt.config.manifestVersion === 3) {
      contentScripts.forEach((script) => {
        script.options.matches.forEach((matchPattern) => {
          addHostPermission(manifest, matchPattern);
        });
      });
    } else {
      const hashToEntrypointsMap = contentScripts.filter((cs) => cs.options.registration !== "runtime").reduce((map, script) => {
        const hash = hashContentScriptOptions(script.options);
        if (map.has(hash))
          map.get(hash)?.push(script);
        else
          map.set(hash, [script]);
        return map;
      }, /* @__PURE__ */ new Map());
      const manifestContentScripts = Array.from(
        hashToEntrypointsMap.values()
      ).map(
        (scripts) => mapWxtOptionsToContentScript(
          scripts[0].options,
          scripts.map(
            (entry) => getEntrypointBundlePath(entry, wxt.config.outDir, ".js")
          ),
          getContentScriptCssFiles(scripts, cssMap)
        )
      );
      if (manifestContentScripts.length >= 0) {
        manifest.content_scripts ??= [];
        manifest.content_scripts.push(...manifestContentScripts);
      }
      const runtimeContentScripts = contentScripts.filter(
        (cs) => cs.options.registration === "runtime"
      );
      if (runtimeContentScripts.length > 0 && wxt.config.manifestVersion === 2) {
        throw Error(
          'Cannot use `registration: "runtime"` with MV2 content scripts, it is a MV3-only feature.'
        );
      }
      runtimeContentScripts.forEach((script) => {
        script.options.matches.forEach((matchPattern) => {
          addHostPermission(manifest, matchPattern);
        });
      });
    }
    const contentScriptCssResources = getContentScriptCssWebAccessibleResources(
      contentScripts,
      cssMap
    );
    if (contentScriptCssResources.length > 0) {
      manifest.web_accessible_resources ??= [];
      manifest.web_accessible_resources.push(...contentScriptCssResources);
    }
  }
}
function discoverIcons(buildOutput) {
  const icons = [];
  const iconRegex = [
    /^icon-([0-9]+)\.png$/,
    // icon-16.png
    /^icon-([0-9]+)x[0-9]+\.png$/,
    // icon-16x16.png
    /^icon@([0-9]+)w\.png$/,
    // icon@16w.png
    /^icon@([0-9]+)h\.png$/,
    // icon@16h.png
    /^icon@([0-9]+)\.png$/,
    // icon@16.png
    /^icons?[\/\\]([0-9]+)\.png$/,
    // icon/16.png | icons/16.png
    /^icons?[\/\\]([0-9]+)x[0-9]+\.png$/
    // icon/16x16.png | icons/16x16.png
  ];
  buildOutput.publicAssets.forEach((asset) => {
    let size;
    for (const regex of iconRegex) {
      const match = asset.fileName.match(regex);
      if (match?.[1] != null) {
        size = match[1];
        break;
      }
    }
    if (size == null)
      return;
    icons.push([size, normalizePath(asset.fileName)]);
  });
  return icons.length > 0 ? Object.fromEntries(icons) : void 0;
}
function addDevModeCsp(manifest) {
  const permission = `http://${wxt.server?.hostname ?? ""}/*`;
  const allowedCsp = wxt.server?.origin ?? "http://localhost:*";
  if (manifest.manifest_version === 3) {
    addHostPermission(manifest, permission);
  } else {
    addPermission(manifest, permission);
  }
  const csp = new ContentSecurityPolicy(
    manifest.manifest_version === 3 ? (
      // @ts-expect-error: extension_pages is not typed
      manifest.content_security_policy?.extension_pages ?? "script-src 'self' 'wasm-unsafe-eval'; object-src 'self';"
    ) : manifest.content_security_policy ?? "script-src 'self'; object-src 'self';"
    // default CSP for MV2
  );
  if (wxt.server)
    csp.add("script-src", allowedCsp);
  if (manifest.manifest_version === 3) {
    manifest.content_security_policy ??= {};
    manifest.content_security_policy.extension_pages = csp.toString();
  } else {
    manifest.content_security_policy = csp.toString();
  }
}
function addDevModePermissions(manifest) {
  addPermission(manifest, "tabs");
  if (wxt.config.manifestVersion === 3)
    addPermission(manifest, "scripting");
}
function getContentScriptCssFiles(contentScripts, contentScriptCssMap) {
  const css = [];
  contentScripts.forEach((script) => {
    if (script.options.cssInjectionMode === "manual" || script.options.cssInjectionMode === "ui")
      return;
    const cssFile = contentScriptCssMap[script.name];
    if (cssFile == null)
      return;
    if (cssFile)
      css.push(cssFile);
  });
  if (css.length > 0)
    return css;
  return void 0;
}
function getContentScriptCssWebAccessibleResources(contentScripts, contentScriptCssMap) {
  const resources = [];
  contentScripts.forEach((script) => {
    if (script.options.cssInjectionMode !== "ui")
      return;
    const cssFile = contentScriptCssMap[script.name];
    if (cssFile == null)
      return;
    resources.push({
      resources: [cssFile],
      matches: script.options.matches.map(
        (matchPattern) => stripPathFromMatchPattern(matchPattern)
      )
    });
  });
  return resources;
}
function getContentScriptsCssMap(buildOutput, scripts) {
  const map = {};
  const allChunks = buildOutput.steps.flatMap((step) => step.chunks);
  scripts.forEach((script) => {
    const relatedCss = allChunks.find(
      (chunk) => chunk.fileName === `content-scripts/${script.name}.css`
    );
    if (relatedCss != null)
      map[script.name] = relatedCss.fileName;
  });
  return map;
}
function addPermission(manifest, permission) {
  manifest.permissions ??= [];
  if (manifest.permissions.includes(permission))
    return;
  manifest.permissions.push(permission);
}
function addHostPermission(manifest, hostPermission) {
  manifest.host_permissions ??= [];
  if (manifest.host_permissions.includes(hostPermission))
    return;
  manifest.host_permissions.push(hostPermission);
}
function stripPathFromMatchPattern(pattern) {
  const protocolSepIndex = pattern.indexOf("://");
  if (protocolSepIndex === -1)
    return pattern;
  const startOfPath = pattern.indexOf("/", protocolSepIndex + 3);
  return pattern.substring(0, startOfPath) + "/*";
}
function convertWebAccessibleResourcesToMv2(manifest) {
  if (manifest.web_accessible_resources == null)
    return;
  manifest.web_accessible_resources = Array.from(
    new Set(
      manifest.web_accessible_resources.flatMap((item) => {
        if (typeof item === "string")
          return item;
        return item.resources;
      })
    )
  );
}
function moveHostPermissionsToPermissions(manifest) {
  if (!manifest.host_permissions?.length)
    return;
  manifest.host_permissions.forEach(
    (permission) => addPermission(manifest, permission)
  );
  delete manifest.host_permissions;
}
function convertActionToMv2(manifest) {
  if (manifest.action == null || manifest.browser_action != null || manifest.page_action != null)
    return;
  manifest.browser_action = manifest.action;
}
function validateMv3WebAccessbileResources(manifest) {
  if (manifest.web_accessible_resources == null)
    return;
  const stringResources = manifest.web_accessible_resources.filter(
    (item) => typeof item === "string"
  );
  if (stringResources.length > 0) {
    throw Error(
      `Non-MV3 web_accessible_resources detected: ${JSON.stringify(
        stringResources
      )}. When manually defining web_accessible_resources, define them as MV3 objects ({ matches: [...], resources: [...] }), and WXT will automatically convert them to MV2 when necessary.`
    );
  }
}
function stripKeys(manifest) {
  let keysToRemove = [];
  if (wxt.config.manifestVersion === 2) {
    keysToRemove.push(...mv3OnlyKeys);
    if (wxt.config.browser === "firefox")
      keysToRemove.push(...firefoxMv3OnlyKeys);
  } else {
    keysToRemove.push(...mv2OnlyKeys);
  }
  keysToRemove.forEach((key) => {
    delete manifest[key];
  });
}
var mv2OnlyKeys = [
  "page_action",
  "browser_action",
  "automation",
  "content_capabilities",
  "converted_from_user_script",
  "current_locale",
  "differential_fingerprint",
  "event_rules",
  "file_browser_handlers",
  "file_system_provider_capabilities",
  "input_components",
  "nacl_modules",
  "natively_connectable",
  "offline_enabled",
  "platforms",
  "replacement_web_app",
  "system_indicator",
  "user_scripts"
];
var mv3OnlyKeys = [
  "action",
  "export",
  "optional_host_permissions",
  "side_panel"
];
var firefoxMv3OnlyKeys = ["host_permissions"];

// src/core/utils/building/rebuild.ts
async function rebuild(allEntrypoints, entrypointGroups, existingOutput = {
  steps: [],
  publicAssets: []
}) {
  const { default: ora } = await import("ora");
  const spinner = ora(`Preparing...`).start();
  await generateTypesDir(allEntrypoints).catch((err) => {
    wxt.logger.warn("Failed to update .wxt directory:", err);
    if (wxt.config.command === "build")
      throw err;
  });
  const newOutput = await buildEntrypoints(entrypointGroups, spinner);
  const mergedOutput = {
    steps: [...existingOutput.steps, ...newOutput.steps],
    publicAssets: [...existingOutput.publicAssets, ...newOutput.publicAssets]
  };
  const { manifest: newManifest, warnings: manifestWarnings } = await generateManifest(allEntrypoints, mergedOutput);
  const finalOutput = {
    manifest: newManifest,
    ...newOutput
  };
  await writeManifest(newManifest, finalOutput);
  spinner.clear().stop();
  return {
    output: {
      manifest: newManifest,
      steps: [...existingOutput.steps, ...finalOutput.steps],
      publicAssets: [
        ...existingOutput.publicAssets,
        ...finalOutput.publicAssets
      ]
    },
    manifest: newManifest,
    warnings: manifestWarnings
  };
}

// src/core/utils/building/internal-build.ts
import { relative as relative6 } from "node:path";

// src/core/utils/validation.ts
function validateEntrypoints(entrypoints) {
  const errors = entrypoints.flatMap((entrypoint) => {
    switch (entrypoint.type) {
      case "content-script":
        return validateContentScriptEntrypoint(entrypoint);
      default:
        return validateBaseEntrypoint(entrypoint);
    }
  });
  let errorCount = 0;
  let warningCount = 0;
  for (const err of errors) {
    if (err.type === "warning")
      warningCount++;
    else
      errorCount++;
  }
  return {
    errors,
    errorCount,
    warningCount
  };
}
function validateContentScriptEntrypoint(definition) {
  const errors = validateBaseEntrypoint(definition);
  if (definition.options.matches == null) {
    errors.push({
      type: "error",
      message: "`matches` is required",
      value: definition.options.matches,
      entrypoint: definition
    });
  }
  return errors;
}
function validateBaseEntrypoint(definition) {
  const errors = [];
  if (definition.options.exclude != null && !Array.isArray(definition.options.exclude)) {
    errors.push({
      type: "error",
      message: "`exclude` must be an array of browser names",
      value: definition.options.exclude,
      entrypoint: definition
    });
  }
  if (definition.options.include != null && !Array.isArray(definition.options.include)) {
    errors.push({
      type: "error",
      message: "`include` must be an array of browser names",
      value: definition.options.include,
      entrypoint: definition
    });
  }
  return errors;
}
var ValidationError = class extends Error {
};

// src/core/utils/building/internal-build.ts
import { mergeJsonOutputs } from "@aklinker1/rollup-plugin-visualizer";
import { isCI } from "ci-info";
async function internalBuild() {
  await wxt.hooks.callHook("build:before", wxt);
  const verb = wxt.config.command === "serve" ? "Pre-rendering" : "Building";
  const target = `${wxt.config.browser}-mv${wxt.config.manifestVersion}`;
  wxt.logger.info(
    `${verb} ${pc5.cyan(target)} for ${pc5.cyan(wxt.config.mode)} with ${pc5.green(
      `${wxt.builder.name} ${wxt.builder.version}`
    )}`
  );
  const startTime = Date.now();
  await fs13.rm(wxt.config.outDir, { recursive: true, force: true });
  await fs13.ensureDir(wxt.config.outDir);
  const entrypoints = await findEntrypoints();
  wxt.logger.debug("Detected entrypoints:", entrypoints);
  const validationResults = validateEntrypoints(entrypoints);
  if (validationResults.errorCount + validationResults.warningCount > 0) {
    printValidationResults(validationResults);
  }
  if (validationResults.errorCount > 0) {
    throw new ValidationError(`Entrypoint validation failed`, {
      cause: validationResults
    });
  }
  const groups = groupEntrypoints(entrypoints);
  await wxt.hooks.callHook("entrypoints:grouped", wxt, groups);
  const { output, warnings } = await rebuild(entrypoints, groups, void 0);
  await wxt.hooks.callHook("build:done", wxt, output);
  await printBuildSummary(
    wxt.logger.success,
    `Built extension in ${formatDuration(Date.now() - startTime)}`,
    output
  );
  for (const warning of warnings) {
    wxt.logger.warn(...warning);
  }
  if (wxt.config.analysis.enabled) {
    await combineAnalysisStats();
    const statsPath = relative6(wxt.config.root, wxt.config.analysis.outputFile);
    wxt.logger.info(
      `Analysis complete:
  ${pc5.gray("\u2514\u2500")} ${pc5.yellow(statsPath)}`
    );
    if (wxt.config.analysis.open) {
      if (isCI) {
        wxt.logger.debug(`Skipped opening ${pc5.yellow(statsPath)} in CI`);
      } else {
        wxt.logger.info(`Opening ${pc5.yellow(statsPath)} in browser...`);
        const { default: open } = await import("open");
        open(wxt.config.analysis.outputFile);
      }
    }
  }
  return output;
}
async function combineAnalysisStats() {
  const unixFiles = await glob3(`${wxt.config.analysis.outputName}-*.json`, {
    cwd: wxt.config.analysis.outputDir,
    absolute: true
  });
  const absolutePaths = unixFiles.map(unnormalizePath);
  await mergeJsonOutputs({
    inputs: absolutePaths,
    template: wxt.config.analysis.template,
    filename: wxt.config.analysis.outputFile
  });
  if (!wxt.config.analysis.keepArtifacts) {
    await Promise.all(absolutePaths.map((statsFile) => fs13.remove(statsFile)));
  }
}
function printValidationResults({
  errorCount,
  errors,
  warningCount
}) {
  (errorCount > 0 ? wxt.logger.error : wxt.logger.warn)(
    `Entrypoint validation failed: ${errorCount} error${errorCount === 1 ? "" : "s"}, ${warningCount} warning${warningCount === 1 ? "" : "s"}`
  );
  const cwd = process.cwd();
  const entrypointErrors = errors.reduce((map, error) => {
    const entryErrors = map.get(error.entrypoint) ?? [];
    entryErrors.push(error);
    map.set(error.entrypoint, entryErrors);
    return map;
  }, /* @__PURE__ */ new Map());
  Array.from(entrypointErrors.entries()).forEach(([entrypoint, errors2]) => {
    consola.log(relative6(cwd, entrypoint.inputPath));
    console.log();
    errors2.forEach((err) => {
      const type = err.type === "error" ? pc5.red("ERROR") : pc5.yellow("WARN");
      const recieved = pc5.dim(`(recieved: ${JSON.stringify(err.value)})`);
      consola.log(`  - ${type} ${err.message} ${recieved}`);
    });
    console.log();
  });
}

// src/core/wxt.ts
import { createHooks } from "hookable";

// src/core/package-managers/index.ts
import {
  detectPackageManager,
  addDependency,
  addDevDependency,
  ensureDependencyInstalled,
  installDependencies,
  removeDependency
} from "nypm";

// src/core/package-managers/npm.ts
import path7 from "node:path";
import { ensureDir as ensureDir3 } from "fs-extra";
var npm = {
  overridesKey: "overrides",
  async downloadDependency(id, downloadDir) {
    await ensureDir3(downloadDir);
    const { execa } = await import("./execa-VDW6HLFV.js");
    const res = await execa("npm", ["pack", id, "--json"], {
      cwd: downloadDir
    });
    const packed = JSON.parse(res.stdout);
    return path7.resolve(downloadDir, packed[0].filename);
  },
  async listDependencies(options) {
    const args = ["ls", "--json"];
    if (options?.all) {
      args.push("--depth", "Infinity");
    }
    const { execa } = await import("./execa-VDW6HLFV.js");
    const res = await execa("npm", args, { cwd: options?.cwd });
    const project = JSON.parse(res.stdout);
    return flattenNpmListOutput([project]);
  }
};
function flattenNpmListOutput(projects) {
  const queue = projects.flatMap(
    (project) => {
      const acc = [];
      if (project.dependencies)
        acc.push(project.dependencies);
      if (project.devDependencies)
        acc.push(project.devDependencies);
      return acc;
    }
  );
  const dependencies = [];
  while (queue.length > 0) {
    Object.entries(queue.pop()).forEach(([name, meta]) => {
      dependencies.push({
        name,
        version: meta.version
      });
      if (meta.dependencies)
        queue.push(meta.dependencies);
      if (meta.devDependencies)
        queue.push(meta.devDependencies);
    });
  }
  return dedupeDependencies(dependencies);
}
function dedupeDependencies(dependencies) {
  const hashes = /* @__PURE__ */ new Set();
  return dependencies.filter((dep) => {
    const hash = `${dep.name}@${dep.version}`;
    if (hashes.has(hash)) {
      return false;
    } else {
      hashes.add(hash);
      return true;
    }
  });
}

// src/core/package-managers/bun.ts
var bun = {
  overridesKey: "overrides",
  // But also supports "resolutions"
  downloadDependency(...args) {
    return npm.downloadDependency(...args);
  },
  async listDependencies(options) {
    const args = ["pm", "ls"];
    if (options?.all) {
      args.push("--all");
    }
    const { execa } = await import("./execa-VDW6HLFV.js");
    const res = await execa("bun", args, { cwd: options?.cwd });
    return dedupeDependencies(
      res.stdout.split("\n").slice(1).map((line) => line.trim()).map((line) => /.* (@?\S+)@(\S+)$/.exec(line)).filter((match) => !!match).map(([_, name, version2]) => ({ name, version: version2 }))
    );
  }
};

// src/core/package-managers/yarn.ts
var yarn = {
  overridesKey: "resolutions",
  downloadDependency(...args) {
    return npm.downloadDependency(...args);
  },
  async listDependencies(options) {
    const args = ["list", "--json"];
    if (options?.all) {
      args.push("--depth", "Infinity");
    }
    const { execa } = await import("./execa-VDW6HLFV.js");
    const res = await execa("yarn", args, { cwd: options?.cwd });
    const tree = res.stdout.split("\n").map((line) => JSON.parse(line)).find((line) => line.type === "tree")?.data;
    if (tree == null)
      throw Error("'yarn list --json' did not output a tree");
    const queue = [...tree.trees];
    const dependencies = [];
    while (queue.length > 0) {
      const { name: treeName, children } = queue.pop();
      const match = /(@?\S+)@(\S+)$/.exec(treeName);
      if (match) {
        const [_, name, version2] = match;
        dependencies.push({ name, version: version2 });
      }
      if (children != null) {
        queue.push(...children);
      }
    }
    return dedupeDependencies(dependencies);
  }
};

// src/core/package-managers/pnpm.ts
var pnpm = {
  overridesKey: "resolutions",
  // "pnpm.overrides" has a higher priority, but I don't want to deal with nesting
  downloadDependency(...args) {
    return npm.downloadDependency(...args);
  },
  async listDependencies(options) {
    const args = ["ls", "-r", "--json"];
    if (options?.all) {
      args.push("--depth", "Infinity");
    }
    if (typeof process !== "undefined" && process.env.WXT_PNPM_IGNORE_WORKSPACE === "true") {
      args.push("--ignore-workspace");
    }
    const { execa } = await import("./execa-VDW6HLFV.js");
    const res = await execa("pnpm", args, { cwd: options?.cwd });
    const projects = JSON.parse(res.stdout);
    return flattenNpmListOutput(projects);
  }
};

// src/core/package-managers/index.ts
async function createWxtPackageManager(root) {
  const pm = await detectPackageManager(root, {
    includeParentDirs: true
  });
  const requirePm = (cb) => {
    if (pm == null)
      throw Error("Could not detect package manager");
    return cb(pm);
  };
  return {
    get name() {
      return requirePm((pm2) => pm2.name);
    },
    get command() {
      return requirePm((pm2) => pm2.command);
    },
    get version() {
      return requirePm((pm2) => pm2.version);
    },
    get majorVersion() {
      return requirePm((pm2) => pm2.majorVersion);
    },
    get lockFile() {
      return requirePm((pm2) => pm2.lockFile);
    },
    get files() {
      return requirePm((pm2) => pm2.files);
    },
    addDependency,
    addDevDependency,
    ensureDependencyInstalled,
    installDependencies,
    removeDependency,
    get overridesKey() {
      return requirePm((pm2) => packageManagers[pm2.name].overridesKey);
    },
    downloadDependency(...args) {
      return requirePm(
        (pm2) => packageManagers[pm2.name].downloadDependency(...args)
      );
    },
    listDependencies(...args) {
      return requirePm(
        (pm2) => packageManagers[pm2.name].listDependencies(...args)
      );
    }
  };
}
var packageManagers = {
  npm,
  pnpm,
  bun,
  yarn
};

// src/core/builders/vite/index.ts
async function createViteBuilder(wxtConfig, hooks, server) {
  const vite = await import("vite");
  const getBaseConfig = async () => {
    const config = await wxtConfig.vite(wxtConfig.env);
    config.root = wxtConfig.root;
    config.configFile = false;
    config.logLevel = "warn";
    config.mode = wxtConfig.mode;
    config.build ??= {};
    config.publicDir = wxtConfig.publicDir;
    config.build.copyPublicDir = false;
    config.build.outDir = wxtConfig.outDir;
    config.build.emptyOutDir = false;
    if (config.build.minify == null && wxtConfig.command === "serve") {
      config.build.minify = false;
    }
    if (config.build.sourcemap == null && wxtConfig.command === "serve") {
      config.build.sourcemap = "inline";
    }
    config.plugins ??= [];
    config.plugins.push(
      download(wxtConfig),
      devHtmlPrerender(wxtConfig, server),
      unimport(wxtConfig),
      resolveVirtualModules(wxtConfig),
      devServerGlobals(wxtConfig, server),
      tsconfigPaths(wxtConfig),
      noopBackground(),
      globals(wxtConfig),
      excludeBrowserPolyfill(wxtConfig),
      defineImportMeta()
    );
    if (wxtConfig.analysis.enabled) {
      config.plugins.push(bundleAnalysis(wxtConfig));
    }
    return config;
  };
  const getLibModeConfig = (entrypoint) => {
    const entry = getRollupEntry(entrypoint);
    const plugins = [
      entrypointGroupGlobals(entrypoint)
    ];
    if (entrypoint.type === "content-script-style" || entrypoint.type === "unlisted-style") {
      plugins.push(cssEntrypoints(entrypoint, wxtConfig));
    }
    const iifeReturnValueName = safeVarName(entrypoint.name);
    const libMode = {
      mode: wxtConfig.mode,
      plugins,
      esbuild: {
        // Add a footer with the returned value so it can return values to `scripting.executeScript`
        // Footer is added apart of esbuild to make sure it's not minified. It
        // get's removed if added to `build.rollupOptions.output.footer`
        // See https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/scripting/executeScript#return_value
        footer: iifeReturnValueName + ";"
      },
      build: {
        lib: {
          entry,
          formats: ["iife"],
          name: iifeReturnValueName,
          fileName: entrypoint.name
        },
        rollupOptions: {
          output: {
            // There's only a single output for this build, so we use the desired bundle path for the
            // entry output (like "content-scripts/overlay.js")
            entryFileNames: getEntrypointBundlePath(
              entrypoint,
              wxtConfig.outDir,
              ".js"
            ),
            // Output content script CSS to `content-scripts/`, but all other scripts are written to
            // `assets/`.
            assetFileNames: ({ name }) => {
              if (entrypoint.type === "content-script" && name?.endsWith("css")) {
                return `content-scripts/${entrypoint.name}.[ext]`;
              } else {
                return `assets/${entrypoint.name}.[ext]`;
              }
            }
          }
        }
      },
      define: {
        // See https://github.com/aklinker1/vite-plugin-web-extension/issues/96
        "process.env.NODE_ENV": JSON.stringify(wxtConfig.mode)
      }
    };
    return libMode;
  };
  const getMultiPageConfig = (entrypoints) => {
    const htmlEntrypoints = new Set(
      entrypoints.filter(isHtmlEntrypoint).map((e) => e.name)
    );
    return {
      mode: wxtConfig.mode,
      plugins: [
        multipageMove(entrypoints, wxtConfig),
        entrypointGroupGlobals(entrypoints)
      ],
      build: {
        rollupOptions: {
          input: entrypoints.reduce((input, entry) => {
            input[entry.name] = getRollupEntry(entry);
            return input;
          }, {}),
          output: {
            // Include a hash to prevent conflicts
            chunkFileNames: "chunks/[name]-[hash].js",
            entryFileNames: ({ name }) => {
              if (htmlEntrypoints.has(name))
                return "chunks/[name]-[hash].js";
              return "[name].js";
            },
            // We can't control the "name", so we need a hash to prevent conflicts
            assetFileNames: "assets/[name]-[hash].[ext]"
          }
        }
      }
    };
  };
  const getCssConfig = (entrypoint) => {
    return {
      mode: wxtConfig.mode,
      plugins: [entrypointGroupGlobals(entrypoint)],
      build: {
        rollupOptions: {
          input: {
            [entrypoint.name]: entrypoint.inputPath
          },
          output: {
            assetFileNames: () => {
              if (entrypoint.type === "content-script-style") {
                return `content-scripts/${entrypoint.name}.[ext]`;
              } else {
                return `assets/${entrypoint.name}.[ext]`;
              }
            }
          }
        }
      }
    };
  };
  return {
    name: "Vite",
    version: vite.version,
    async importEntrypoint(url) {
      const baseConfig = await getBaseConfig();
      const envConfig = {
        plugins: [
          webextensionPolyfillMock(wxtConfig),
          removeEntrypointMainFunction(wxtConfig, url)
        ]
      };
      const config = vite.mergeConfig(baseConfig, envConfig);
      const server2 = await vite.createServer(config);
      await server2.listen();
      const runtime = await vite.createViteRuntime(server2, { hmr: false });
      const module = await runtime.executeUrl(url);
      await server2.close();
      return module.default;
    },
    async build(group) {
      let entryConfig;
      if (Array.isArray(group))
        entryConfig = getMultiPageConfig(group);
      else if (group.inputPath.endsWith(".css"))
        entryConfig = getCssConfig(group);
      else
        entryConfig = getLibModeConfig(group);
      const buildConfig = vite.mergeConfig(await getBaseConfig(), entryConfig);
      await hooks.callHook(
        "vite:build:extendConfig",
        toArray(group),
        buildConfig
      );
      const result = await vite.build(buildConfig);
      return {
        entrypoints: group,
        chunks: getBuildOutputChunks(result)
      };
    },
    async createServer(info) {
      const serverConfig = {
        server: {
          port: info.port,
          strictPort: true,
          host: info.hostname,
          origin: info.origin
        }
      };
      const baseConfig = await getBaseConfig();
      const finalConfig = vite.mergeConfig(baseConfig, serverConfig);
      await hooks.callHook("vite:devServer:extendConfig", finalConfig);
      const viteServer = await vite.createServer(finalConfig);
      const server2 = {
        async listen() {
          await viteServer.listen(info.port);
        },
        async close() {
          await viteServer.close();
        },
        transformHtml(...args) {
          return viteServer.transformIndexHtml(...args);
        },
        ws: {
          send(message, payload) {
            return viteServer.ws.send(message, payload);
          },
          on(message, cb) {
            viteServer.ws.on(message, cb);
          }
        },
        watcher: viteServer.watcher
      };
      return server2;
    }
  };
}
function getBuildOutputChunks(result) {
  if ("on" in result)
    throw Error("wxt does not support vite watch mode.");
  if (Array.isArray(result))
    return result.flatMap(({ output }) => output);
  return result.output;
}
function getRollupEntry(entrypoint) {
  let virtualEntrypointType;
  switch (entrypoint.type) {
    case "background":
    case "unlisted-script":
      virtualEntrypointType = entrypoint.type;
      break;
    case "content-script":
      virtualEntrypointType = entrypoint.options.world === "MAIN" ? "content-script-main-world" : "content-script-isolated-world";
      break;
  }
  if (virtualEntrypointType) {
    const moduleId = `virtual:wxt-${virtualEntrypointType}-entrypoint`;
    return `${moduleId}?${entrypoint.inputPath}`;
  }
  return entrypoint.inputPath;
}

// src/core/wxt.ts
var wxt;
async function registerWxt(command, inlineConfig = {}, getServer) {
  const hooks = createHooks();
  const config = await resolveConfig(inlineConfig, command);
  const server = await getServer?.(config);
  const builder = await createViteBuilder(config, hooks, server);
  const pm = await createWxtPackageManager(config.root);
  wxt = {
    config,
    hooks,
    get logger() {
      return config.logger;
    },
    async reloadConfig() {
      wxt.config = await resolveConfig(inlineConfig, command);
    },
    pm,
    builder,
    server
  };
  wxt.hooks.addHooks(config.hooks);
  await wxt.hooks.callHook("ready", wxt);
}

export {
  normalizePath,
  unnormalizePath,
  getEntrypointBundlePath,
  isHtmlEntrypoint,
  formatDuration,
  download,
  unimport,
  tsconfigPaths,
  globals,
  webextensionPolyfillMock,
  kebabCaseAlphanumeric,
  wxt,
  registerWxt,
  detectDevChanges,
  findEntrypoints,
  generateTypesDir,
  getPackageJson,
  resolveConfig,
  printFileList,
  version,
  mapWxtOptionsToRegisteredContentScript,
  getContentScriptJs,
  getContentScriptCssFiles,
  getContentScriptsCssMap,
  rebuild,
  internalBuild
};
